<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-max-osx.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Write Something I Want">
<meta property="og:type" content="website">
<meta property="og:title" content="Air Little Place">
<meta property="og:url" content="http://air.com/index.html">
<meta property="og:site_name" content="Air Little Place">
<meta property="og:description" content="Write Something I Want">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Air Little Place">
<meta name="twitter:description" content="Write Something I Want">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Air Little Place</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Air Little Place</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2017/05/31/AndroidPlugin源码解析(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/AndroidPlugin源码解析(二)/" itemprop="url">AndroidPlugin源码解析(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T00:00:00+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章还没分析完，还留了剩下两步，这一篇我们继续跟进。<br>先从第三步开始：</p>
<h3 id="BasePlugin-createTasks"><a href="#BasePlugin-createTasks" class="headerlink" title="BasePlugin createTasks"></a>BasePlugin createTasks</h3><p>看<code>apply</code>方法中第三个过程<code>createTasks()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">    taskManager.createTasksBeforeEvaluate(</div><div class="line">                            <span class="keyword">new</span> TaskContainerAdaptor(project.getTasks()));</div><div class="line">    createAndroidTasks(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法很短，里面的内容就两个方法。<br>第一个方法里面创建了一些task，可是这些task和我们打包过程基本无关，所以这里忽视掉。<br>跳过了一些ndk相关的代码，来看看第二个方法</p>
<h4 id="BasePlugin-createAndroidTasks"><a href="#BasePlugin-createAndroidTasks" class="headerlink" title="BasePlugin createAndroidTasks"></a>BasePlugin createAndroidTasks</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@VisibleForTesting</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createAndroidTasks</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检测buildToolVersion,compileSdkVersion的设置</span></div><div class="line">    <span class="comment">// Make sure unit tests set the required fields.</span></div><div class="line">    checkState(extension.getBuildToolsRevision() != <span class="keyword">null</span>,</div><div class="line">            <span class="string">"buildToolsVersion is not specified."</span>);</div><div class="line">    checkState(extension.getCompileSdkVersion() != <span class="keyword">null</span>, <span class="string">"compileSdkVersion is not specified."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 不允许依赖java plugin</span></div><div class="line">    <span class="comment">// get current plugins and look for the default Java plugin.</span></div><div class="line">    <span class="keyword">if</span> (project.getPlugins().hasPlugin(JavaPlugin.class)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadPluginException(</div><div class="line">                <span class="string">"The 'java' plugin has been applied, but it is not compatible with the Android plugins."</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化TargetInfo这个类</span></div><div class="line">    <span class="comment">// 这个类负责给build project的时候提供需要的信息</span></div><div class="line">    ensureTargetSetup();</div><div class="line"></div><div class="line">    <span class="comment">// don't do anything if the project was not initialized.</span></div><div class="line">    <span class="comment">// Unless TEST_SDK_DIR is set in which case this is unit tests and we don't return.</span></div><div class="line">    <span class="comment">// This is because project don't get evaluated in the unit test setup.</span></div><div class="line">    <span class="comment">// See AppPluginDslTest</span></div><div class="line">    <span class="keyword">if</span> (!force</div><div class="line">            &amp;&amp; (!project.getState().getExecuted() || project.getState().getFailure() != <span class="keyword">null</span>)</div><div class="line">            &amp;&amp; SdkHandler.sTestSdkFolder == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasCreatedTasks) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    hasCreatedTasks = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    extension.disableWrite();</div><div class="line"></div><div class="line">    <span class="comment">// 移除远端Android sdk Maven依赖，改为本地，并将Android sdk Maven依赖放置到最前方</span></div><div class="line">    <span class="comment">// setup Android SDK repositories.</span></div><div class="line">    sdkHandler.addLocalRepositories(project);</div><div class="line">    <span class="comment">// databinding相关</span></div><div class="line">    taskManager.addDataBindingDependenciesIfNecessary(extension.getDataBinding());</div><div class="line">  </div><div class="line">    variantManager.createAndroidTasks();</div><div class="line">    </div><div class="line">    ApiObjectFactory apiObjectFactory = <span class="keyword">new</span> ApiObjectFactory(</div><div class="line">            androidBuilder, extension, variantFactory, instantiator);</div><div class="line">    <span class="keyword">for</span> (BaseVariantData variantData : variantManager.getVariantDataList())  &#123;</div><div class="line">        apiObjectFactory.create(variantData);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的通过注释能了解一个大概，后面的很重要，也无法用注释来简单说明。<br>这个方法里有一个方法是最重要的，那就是<code>variantManager.createAndroidTasks();</code><br>我们来看一看这个方法</p>
<h4 id="VariantManager-createAndroidTasks"><a href="#VariantManager-createAndroidTasks" class="headerlink" title="VariantManager createAndroidTasks"></a>VariantManager createAndroidTasks</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAndroidTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里主要是检测Libray plugin情况下 ProductFlavor和BuildType不能添加applicationIdSuffix和Jack支持</span></div><div class="line">    <span class="comment">// 以及ProductFlavor不能重写applicationId</span></div><div class="line">    variantFactory.validateModel(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 这个只是在AndroidTest的时候做了操作</span></div><div class="line">    variantFactory.preVariantWork(project);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> TaskFactory tasks = <span class="keyword">new</span> TaskContainerAdaptor(project.getTasks());</div><div class="line">    <span class="comment">// 生成我们选择最终编译出来的Variant, 比如debugProd。就是BuildType和ProductFlaovr结合生成的</span></div><div class="line">    <span class="comment">// ProductFlavor自身也可以通过dimensions结合，参见http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Multi-flavor-variants</span></div><div class="line">    <span class="keyword">if</span> (variantDataList.isEmpty()) &#123;</div><div class="line">        populateVariantDataList();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Create top level test tasks.</span></div><div class="line">    taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData : variantDataList) &#123;</div><div class="line">        createTasksForVariantData(tasks, variantData);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 类似androidDependencies之类的获取信息的task</span></div><div class="line">    taskManager.createReportTasks(tasks, variantDataList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里提一点，我们项目里出现的<code>defaultConfig</code>其实就是<code>ProductFlavor</code>；<br>所以，所有<code>defaultConfig</code>里出现的设置，都可以在<code>ProductFlavor</code>中修改。</p>
<p>我们来仔细看一下这个方法<code>createTasksForVariantData(tasks, variantData);</code>,这个方法描述了打包流程。所以这个方法很重要。<br>去掉为测试生成的task代码</p>
<h4 id="VariantManager-createTasksForVariantData"><a href="#VariantManager-createTasksForVariantData" class="headerlink" title="VariantManager createTasksForVariantData"></a>VariantManager createTasksForVariantData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Create tasks for the specified variantData.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">final</span> TaskFactory tasks,</div><div class="line">        <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData) &#123;</div><div class="line">    <span class="keyword">final</span> BuildTypeData buildTypeData = buildTypes.get(</div><div class="line">            variantData.getVariantConfiguration().getBuildType().getName());</div><div class="line">    <span class="comment">// 创建类似于AssembleDebug,　AssembleRelease之类的Ｔａｓｋ</span></div><div class="line">    <span class="keyword">if</span> (buildTypeData.getAssembleTask() == <span class="keyword">null</span>) &#123;</div><div class="line">        buildTypeData.setAssembleTask(taskManager.createAssembleTask(tasks, buildTypeData));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Add dependency of assemble task on assemble build type task.</span></div><div class="line">    tasks.named(<span class="string">"assemble"</span>, <span class="keyword">new</span> Action&lt;Task&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</div><div class="line">            <span class="keyword">assert</span> buildTypeData.getAssembleTask() != <span class="keyword">null</span>;</div><div class="line">            task.dependsOn(buildTypeData.getAssembleTask().getName());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    VariantType variantType = variantData.getType();</div><div class="line">    <span class="comment">// 把ProductFlaovr的Assemble任务加上</span></div><div class="line">    createAssembleTaskForVariantData(tasks, variantData);</div><div class="line"></div><div class="line">    taskManager.createTasksForVariantData(tasks, variantData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法里最重要的就是最后一行<code>taskManager.createTasksForVariantData(tasks, variantData);</code>，不管Test的情况下分为两种实现，一种是application，一种是library，这里我们先放着，因为这里是整个打包过程具体实现的地方，下一系列文章(Android打包过程解析)来解析这个方法的代码。<br>本篇文章继续往下跟进。</p>
<p>打包过程的第一阶段——配置，到这里还剩最后一个方法就完成了，我们来看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ApiObjectFactory apiObjectFactory = <span class="keyword">new</span> ApiObjectFactory(</div><div class="line">    androidBuilder, extension, variantFactory, instantiator);</div><div class="line">    <span class="comment">// variantManager.getVariantDataList() 就是前面创建的ProductFlavor</span></div><div class="line"><span class="keyword">for</span> (BaseVariantData variantData : variantManager.getVariantDataList())  &#123;</div><div class="line">    apiObjectFactory.create(variantData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看看<code>create</code>方法</p>
<h4 id="ApiObjectFactory-create"><a href="#ApiObjectFactory-create" class="headerlink" title="ApiObjectFactory create"></a>ApiObjectFactory create</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(BaseVariantData&lt;?&gt; variantData)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个方法主要目的是把output对象和variant对象关联起来</span></div><div class="line">    BaseVariant variantApi =</div><div class="line">            variantFactory.createVariantApi(variantData, readOnlyObjectProvider);</div><div class="line">    <span class="comment">// Only add the variant API object to the domain object set once it's been fully</span></div><div class="line">    <span class="comment">// initialized.</span></div><div class="line">    extension.addVariant(variantApi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管Test相关的代码的话，我们可以看到，这个方法变成了只有两行，且最后一个方法的注释明显的写明了初始化完毕(it’s been fully initialized)。</p>
<p>最后那个extension对象就是我们刚开始用的Android Extension对象。将variant加入Android Extension对象，初始化就完毕了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2017/05/30/AndroidPlugin源码解析(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/AndroidPlugin源码解析(一)/" itemprop="url">AndroidPlugin源码解析(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T00:00:00+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我们知道<code>com.android.application</code> plugin对应的类为<code>com.android.build.gradle.AppPlugin</code></p>
<p>这个类的声明为: <code>public class AppPlugin extends BasePlugin implements Plugin&lt;Project&gt;</code></p>
<p>看到最后<code>implements Plugin&lt;Project&gt;</code>，熟悉gradle plugin的人应该知道，<br><code>apply plugin: &#39;com.android.application&#39;</code>其实就是调用<code>AppPlugin类</code>的<code>public void apply(@NonNull Project project)</code>方法。</p>
<p><code>com.android.library</code> plugin对应的类为<code>com.android.build.gradle.LibraryPlugin</code>。</p>
<p>这个类的声明为: <code>public class LibraryPlugin extends BasePlugin implements Plugin&lt;Project&gt;</code></p>
<p>这个两个<code>apply</code>方法的具体内容只有一点点不同，两个都调用了<code>super.apply(project)</code>方法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void apply(@NonNull Project project) &#123;</div><div class="line">    super.apply(project);</div><div class="line">    // 下面的代码只在Library plugin中存在</div><div class="line">    // Default assemble task for the default-published artifact.</div><div class="line">    // This is needed for the prepare task on the consuming project.</div><div class="line">    project.getTasks().create("assembleDefault");</div><div class="line">&#125;</div><div class="line">~~~ </div><div class="line"></div><div class="line">接下来我们一步步的跟进:</div><div class="line"></div><div class="line">### BasePlugin apply</div><div class="line"></div><div class="line">可以看到，就是调用了BasePlugin的`apply`方法。我们来看一下BasePlugin的`apply`方法做了什么。</div><div class="line">老规矩，分析中会去掉日志，记录，错误检查之类的代码。</div><div class="line"></div><div class="line">~~~ java</div><div class="line">// 去掉那些我认为不重要的代码后，整个apply方法的流程如下。</div><div class="line">protected void apply(@NonNull Project project) &#123;</div><div class="line">    configureProject();</div><div class="line">    createExtension();</div><div class="line">    createTasks();</div><div class="line">    // 读取 "android.additional.plugins"对应的插件名称</div><div class="line">    // Apply additional plugins</div><div class="line">    for (String plugin : AndroidGradleOptions.getAdditionalPlugins(project)) &#123;</div><div class="line">        project.apply(ImmutableMap.of("plugin", plugin));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，其实整个<code>apply</code>方法分4步，最后一步读取插件没有什么好分析的，对于剩下三步来说本篇文章只分析前两步。</p>
<h3 id="BasePlugin-configureProject"><a href="#BasePlugin-configureProject" class="headerlink" title="BasePlugin configureProject"></a>BasePlugin configureProject</h3><p>我们一个过程一个过程研究。<br>先看<code>configureProject()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">String creator = <span class="string">"Android Gradle "</span> Version.ANDROID_GRADLE_PLUGIN_VERSION;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureProject</span><span class="params">()</span> </span>&#123;</div><div class="line">    sdkHandler = <span class="keyword">new</span> SdkHandler(project, getLogger());</div><div class="line">    </div><div class="line">    androidBuilder = <span class="keyword">new</span> AndroidBuilder(</div><div class="line">            project == project.getRootProject() ? project.getName() : project.getPath(), <span class="comment">// project Id</span></div><div class="line">            creator, <span class="comment">// the createdBy String for the apk manifest（打包之后的MANIFEST.MF文件可以看到）</span></div><div class="line">            <span class="keyword">new</span> GradleProcessExecutor(project),  <span class="comment">// An executor for external processes.</span></div><div class="line">            <span class="keyword">new</span> GradleJavaProcessExecutor(project), <span class="comment">// An executor for external Java-based processes.</span></div><div class="line">            extraModelInfo,</div><div class="line">            getLogger(),</div><div class="line">            isVerbose());</div><div class="line">    </div><div class="line">    project.getPlugins().apply(JavaBasePlugin.class);</div><div class="line">    jacocoPlugin = project.getPlugins().apply(JacocoPlugin.class);</div><div class="line">    project.getTasks().getByName(<span class="string">"assemble"</span>).setDescription(</div><div class="line">            <span class="string">"Assembles all variants of all applications and secondary packages."</span>);</div><div class="line">    <span class="comment">// call back on execution. This is called after the whole build is done (not</span></div><div class="line">    <span class="comment">// after the current project is done).</span></div><div class="line">    <span class="comment">// This is will be called for each (android) projects though, so this should support</span></div><div class="line">    <span class="comment">// being called 2+ times.</span></div><div class="line">    project.getGradle().addBuildListener(<span class="keyword">new</span> BuildListener() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> LibraryCache libraryCache = LibraryCache.getCache();</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildStarted</span><span class="params">(Gradle gradle)</span> </span>&#123; &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settingsEvaluated</span><span class="params">(Settings settings)</span> </span>&#123; &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">projectsLoaded</span><span class="params">(Gradle gradle)</span> </span>&#123; &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">projectsEvaluated</span><span class="params">(Gradle gradle)</span> </span>&#123; &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFinished</span><span class="params">(BuildResult buildResult)</span> </span>&#123;</div><div class="line">            ExecutorSingleton.shutdown();</div><div class="line">            sdkHandler.unload();</div><div class="line">            PreDexCache.getCache().clear(</div><div class="line">                                    <span class="keyword">new</span> File(project.getRootProject().getBuildDir(),</div><div class="line">                                    FD_INTERMEDIATES + <span class="string">"/dex-cache/cache.xml"</span>),</div><div class="line">                                    getLogger());</div><div class="line">                            JackConversionCache.getCache().clear(</div><div class="line">                                    <span class="keyword">new</span> File(project.getRootProject().getBuildDir(),</div><div class="line">                                    FD_INTERMEDIATES + <span class="string">"/jack-cache/cache.xml"</span>),</div><div class="line">                                    getLogger());</div><div class="line">            libraryCache.unload();</div><div class="line">            Main.clearInternTables();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    project.getGradle().getTaskGraph().addTaskExecutionGraphListener(</div><div class="line">            <span class="keyword">new</span> TaskExecutionGraphListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">graphPopulated</span><span class="params">(TaskExecutionGraph taskGraph)</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (Task task : taskGraph.getAllTasks()) &#123;</div><div class="line">                        <span class="keyword">if</span> (task <span class="keyword">instanceof</span> TransformTask) &#123;</div><div class="line">                            Transform transform = ((TransformTask) task).getTransform();</div><div class="line">                            <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> DexTransform) &#123;</div><div class="line">                                PreDexCache.getCache().load(</div><div class="line">                                        <span class="keyword">new</span> File(project.getRootProject().getBuildDir(),</div><div class="line">                                        FD_INTERMEDIATES + <span class="string">"/dex-cache/cache.xml"</span>));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> JackPreDexTransform) &#123;</div><div class="line">                                JackConversionCache.getCache().load(</div><div class="line">                                        <span class="keyword">new</span> File(project.getRootProject().getBuildDir(),</div><div class="line">                                        FD_INTERMEDIATES + <span class="string">"/jack-cache/cache.xml"</span>));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法主要做了如下几个操作:</p>
<ul>
<li>初始化SdkHandler</li>
<li>初始化AndroidBuilder</li>
<li>依赖JavaBasePlugin，JacocoPlugin；这两个Plugin的apply()方法我这里就不写了，大家有兴趣就像本文一样跟进去即可。</li>
<li>给”assemble”任务加上说明</li>
<li>当Gradle Build完成的时候做一些关闭和清理的操作</li>
<li>在Transform任务真正执行之前，读取对应的Cache。</li>
</ul>
<p>SdkHandler主要作用是找local.properties文件里SdkLocation和NdkLocation<br>SdkLocation的查找顺序为：</p>
<pre><code>1. local.properties文件里sdk.dir的配置
2. local.properties文件里android.dir的配置
3. 环境变量&quot;ANDROID_HOME&quot;
4. 环境变量&quot;android.home&quot;
</code></pre><p>NdkLocation的查找顺序为：</p>
<pre><code>1. local.properties文件里ndk.dir的配置
2. 环境变量&quot;ANDROID_NDK_HOME&quot;
</code></pre><p>AndroidBuilder对象主要的几个参数的含义从我在代码中添加的注释即可了解。<br>最后讲一下<code>TaskExecutionGraphListener</code>这个接口。<br>官方文档是这样说的: </p>
<p>&gt;<br>    A TaskExecutionGraphListener is notified when the TaskExecutionGraph has been populated.<br>    You can use this interface in your build file to perform some action based on the contents of the graph,<br>    before any tasks are actually executed.</p>
<p>大概翻译一下，当Gradle将所有task的关系图填充之后，该接口会被调用。<br>你可以在build文件中使用这个接口，在任意task真正执行之前，去完成一些基于task关系图内容的任务。<br>所以这里可以根据对应的Task，判断Task的类型，做对应的操作。</p>
<h3 id="BasePlugin-createExtension"><a href="#BasePlugin-createExtension" class="headerlink" title="BasePlugin createExtension"></a>BasePlugin createExtension</h3><p>继续看<code>apply</code>方法中第二个过程<code>createExtension()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createExtension</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 保存BuildType的NamedDomainObjectContainer</span></div><div class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer = project.container(</div><div class="line">            BuildType.class,</div><div class="line">            <span class="keyword">new</span> BuildTypeFactory(instantiator, project, project.getLogger())); </div><div class="line">    <span class="comment">// 保存ProductFlavor的NamedDomainObjectContainer</span></div><div class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer = project.container(</div><div class="line">            ProductFlavor.class,</div><div class="line">            <span class="keyword">new</span> ProductFlavorFactory(instantiator, project, project.getLogger(), extraModelInfo));</div><div class="line">    <span class="comment">// 保存SigningConfig的NamedDomainObjectContainer</span></div><div class="line">    <span class="keyword">final</span> NamedDomainObjectContainer&lt;SigningConfig&gt;  signingConfigContainer = project.container(</div><div class="line">            SigningConfig.class,</div><div class="line">            <span class="keyword">new</span> SigningConfigFactory(instantiator));</div><div class="line">    <span class="comment">// 创建android这个extension</span></div><div class="line">    extension = project.getExtensions().create(<span class="string">"android"</span>, getExtensionClass(),</div><div class="line">            project, instantiator, androidBuilder, sdkHandler,</div><div class="line">            buildTypeContainer, productFlavorContainer, signingConfigContainer,</div><div class="line">            extraModelInfo, isLibrary());</div><div class="line"></div><div class="line">    <span class="comment">// create the default mapping configuration.</span></div><div class="line">    <span class="comment">// 创建default-mapping和default-metadata两个configuration，并加入描述</span></div><div class="line">    <span class="comment">// 具体的作用暂时没有看出来,如果你知道，欢迎留言告诉我</span></div><div class="line">    <span class="comment">// 通过如下代码放在build.gradle，可以打印出当前所有的configuration</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">        configurations.names.forEach(new Consumer&lt;String&gt;() &#123;</div><div class="line">                <span class="doctag">@Override</span></div><div class="line">                void accept(String s) &#123;</div><div class="line">                        println "configurations：" + s;</div><div class="line">                &#125;</div><div class="line">        &#125;)</div><div class="line">    */</div><div class="line">    project.getConfigurations().create(<span class="string">"default"</span> + VariantDependencies.CONFIGURATION_MAPPING)</div><div class="line">            .setDescription(<span class="string">"Configuration for default mapping artifacts."</span>);</div><div class="line">    project.getConfigurations().create(<span class="string">"default"</span> + VariantDependencies.CONFIGURATION_METADATA)</div><div class="line">            .setDescription(<span class="string">"Metadata for the produced APKs."</span>);</div><div class="line">    <span class="comment">// 创建DependencyManager, 负责管理配置的所有依赖</span></div><div class="line">    dependencyManager = <span class="keyword">new</span> DependencyManager(</div><div class="line">            project,</div><div class="line">            extraModelInfo,</div><div class="line">            sdkHandler);</div><div class="line">    <span class="comment">// 负责管理ndk相关，这里略过不提</span></div><div class="line">    ndkHandler = <span class="keyword">new</span> NdkHandler(</div><div class="line">            project.getRootDir(),</div><div class="line">            <span class="keyword">null</span>, <span class="comment">/* compileSkdVersion, this will be set in afterEvaluate */</span></div><div class="line">            <span class="string">"gcc"</span>,<span class="comment">/* toolchainName */</span></div><div class="line">            <span class="string">""</span> <span class="comment">/*toolchainVersion*/</span>);</div><div class="line">    <span class="comment">// 负责创建taskManager</span></div><div class="line">    taskManager = createTaskManager(</div><div class="line">            project,</div><div class="line">            androidBuilder,</div><div class="line">            dataBindingBuilder,</div><div class="line">            extension,</div><div class="line">            sdkHandler,</div><div class="line">            ndkHandler,</div><div class="line">            dependencyManager,</div><div class="line">            registry);</div><div class="line">    </div><div class="line">    <span class="comment">// 负责创建variant</span></div><div class="line">    variantFactory = createVariantFactory();</div><div class="line">    variantManager = <span class="keyword">new</span> VariantManager(</div><div class="line">            project,</div><div class="line">            androidBuilder,</div><div class="line">            extension,</div><div class="line">            variantFactory,</div><div class="line">            taskManager,</div><div class="line">            instantiator);</div><div class="line"></div><div class="line">    <span class="comment">// Register a builder for the custom tooling model</span></div><div class="line">    ModelBuilder modelBuilder = <span class="keyword">new</span> ModelBuilder(</div><div class="line">            androidBuilder,</div><div class="line">            variantManager,</div><div class="line">            taskManager,</div><div class="line">            extension,</div><div class="line">            extraModelInfo,</div><div class="line">            ndkHandler,</div><div class="line">            <span class="keyword">new</span> NativeLibraryFactoryImpl(ndkHandler),</div><div class="line">            isLibrary(),</div><div class="line">            AndroidProject.GENERATION_ORIGINAL);</div><div class="line">    registry.register(modelBuilder);</div><div class="line"></div><div class="line">    <span class="comment">// Register a builder for the native tooling model</span></div><div class="line">    NativeModelBuilder nativeModelBuilder = <span class="keyword">new</span> NativeModelBuilder(variantManager);</div><div class="line">    registry.register(nativeModelBuilder);</div><div class="line"></div><div class="line">    <span class="comment">// 下面三个whenObjectAdded方法从名字上就很好理解</span></div><div class="line">    <span class="comment">// 当你添加一个对应的对象的时候，回调此方法，也就是需要在variantManager里面添加对应的对象</span></div><div class="line"></div><div class="line">    <span class="comment">// map the whenObjectAdded callbacks on the containers.</span></div><div class="line">    signingConfigContainer.whenObjectAdded(<span class="keyword">new</span> Action&lt;SigningConfig&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(SigningConfig signingConfig)</span> </span>&#123;</div><div class="line">            variantManager.addSigningConfig(signingConfig);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    buildTypeContainer.whenObjectAdded(<span class="keyword">new</span> Action&lt;BuildType&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(BuildType buildType)</span> </span>&#123;</div><div class="line">            <span class="comment">// 默认debug签名</span></div><div class="line">            SigningConfig signingConfig = signingConfigContainer.findByName(BuilderConstants.DEBUG);</div><div class="line">            buildType.init(signingConfig);</div><div class="line">            variantManager.addBuildType(buildType);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    productFlavorContainer.whenObjectAdded(<span class="keyword">new</span> Action&lt;ProductFlavor&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ProductFlavor productFlavor)</span> </span>&#123;</div><div class="line">            variantManager.addProductFlavor(productFlavor);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 同上面类似，三个回调方法，不过是移除的时候抛出异常</span></div><div class="line">    <span class="comment">// 这个只能讲一下注释，具体如何复现暂时我不了解</span></div><div class="line">    <span class="comment">// map whenObjectRemoved on the containers to throw an exception.</span></div><div class="line">    signingConfigContainer.whenObjectRemoved(</div><div class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">"Removing signingConfigs is not supported."</span>));</div><div class="line">    buildTypeContainer.whenObjectRemoved(</div><div class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">"Removing build types is not supported."</span>));</div><div class="line">    productFlavorContainer.whenObjectRemoved(</div><div class="line">            <span class="keyword">new</span> UnsupportedAction(<span class="string">"Removing product flavors is not supported."</span>));</div><div class="line">    </div><div class="line">    <span class="comment">// 最后创建了这些默认的对象</span></div><div class="line">    <span class="comment">// create default Objects, signingConfig first as its used by the BuildTypes.</span></div><div class="line">    variantFactory.createDefaultComponents(</div><div class="line">            buildTypeContainer, productFlavorContainer, signingConfigContainer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这么长的代码，本想去掉点，发现这里面去什么都不合适。<br>那么跟着我慢慢看一下。这里有几个地方需要解释:</p>
<ul>
<li><code>NamedDomainObjectContainer</code>是什么？</li>
</ul>
<p><code>NamedDomainObjectContainer</code>简单来说就是一个容器，里面的泛型<t>保存了容器里面需要传的类型，类似一个List<t>。</t></t></p>
<ul>
<li>extension的创建代表了什么?</li>
</ul>
<p>extension的创建代表了我们在build.gradle文件中，可以使用</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的闭包来给该扩展传消息。我们在<code>{}</code>内写的任何被允许的内容，在这里都被定义好了。从<code>getExtensionClass</code>方法获取具体的Class，<br>application: 使用<code>com.android.build.gradle.AppExtension.class</code><br>library: 使用<code>com.android.build.gradle.LibraryExtension.class</code>。<br>后面的值都是负责初始化这两个类的时候传入的值。</p>
<ul>
<li>TaskManager的作用?</li>
</ul>
<p>首先这个依旧根据application和library做区分。<br>application: 创建<code>ApplicationTaskManager</code><br>library: 创建<code>LibraryTaskManager</code><br>这两个类就是负责创建我们用来处理Android源码的Gradle Task的地方，比如assemblyDebug, installDebug…<br>现在这里大概了解一下这个对象，后面再细细解读此对象。</p>
<ul>
<li>VariantManager的作用？</li>
</ul>
<p>这就是管理<code>Build Variant</code>的地方，<code>Build Variant</code>的意义就是<code>build type</code>和<code>product flavor</code>交叉形成的，换句话说就是合并这两个东东的属性形成<code>Build Variant</code>的配置。<br>暂时也是单纯的提一下，后面再细细解读。</p>
<p><code>ModelBuilder</code>, <code>NativeModelBuilder</code>和<code>private ToolingModelBuilderRegistry registry</code>这三个对象我们都先放一下，<br>这个和Android Plugin本身无关，是和gradle的运行机制相关的东东。</p>
<p>好了，这里大概梳理一下此方法的逻辑，</p>
<ul>
<li>创建<code>buildTypeContainer</code>, <code>productFlavorContainer</code>, <code>signingConfigContainer</code></li>
<li>将android这个extension加入build.gradle</li>
<li>创建一些后面要使用的对象主要指<code>ModelBuilder</code>和<code>NativeModelBuilder</code>,注册到gradle中。</li>
<li>给上面提到的Container加一些回调</li>
<li>通过<code>variantFactory</code>给Container创建默认的配置</li>
</ul>
<p>看一下这个默认的配置，App和Library的默认配置是相同的，都是如下代码。</p>
<h4 id="VariantFactory-createDefaultComponents"><a href="#VariantFactory-createDefaultComponents" class="headerlink" title="VariantFactory createDefaultComponents"></a>VariantFactory createDefaultComponents</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDefaultComponents</span><span class="params">(</span></span></div><div class="line">        @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypes,</div><div class="line">        @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors,</div><div class="line">        @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs) &#123;</div><div class="line">    <span class="comment">// must create signing config first so that build type 'debug' can be initialized</span></div><div class="line">    <span class="comment">// with the debug signing config.</span></div><div class="line">    signingConfigs.create(DEBUG);</div><div class="line">    buildTypes.create(DEBUG);</div><div class="line">    buildTypes.create(RELEASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来我们的SigningConfigs里面默认有debug类型。<br>为什么不需要写signingConfig就有个默认的debug签名？就是这里配置的。<br>同理，为什么新建工程buildTypes有debug和release？就是这里创建的。<br>这里就相当于我们在<code>build.gradle</code>文件写了如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">android&#123;</div><div class="line">    signingConfigs &#123;</div><div class="line">        debug &#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    buildTypes &#123;</div><div class="line">        debug &#123;&#125;</div><div class="line">        release &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法到这里也就暂时过完了。所以这一篇到这里就告一段落了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2017/05/29/AndroidPlugin概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/29/AndroidPlugin概述/" itemprop="url">Android Plugin 概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-29T00:00:00+08:00">
                2017-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Plugin前言"><a href="#Plugin前言" class="headerlink" title="Plugin前言"></a>Plugin前言</h2><p>用Android Studio的会发现，我们新建的Android工程会在根目录的<code>build.gradle</code>文件内引入一个classpath:<br><code>classpath &#39;com.android.tools.build:gradle:x.y.z&#39;</code>,</p>
<p>我们还会在<code>build.gradle</code>引入如下的plugin:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app </span></div><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line"><span class="comment">// library</span></div><div class="line">apply plugin: <span class="string">'com.android.library'</span></div></pre></td></tr></table></figure>
<p>我们同时会在如下的范围内配置各种东东</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这到底是怎么工作的呢？</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>这其实是一个Gradle Plugin，它表示引入了<code>com.android.tools.build:gradle-x.y.z</code>的jar包。这个包需要在repositories里面声明的位置找。<br>引入了这样一个jar包，我们才能引入必要的plugin:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app </span></div><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line"><span class="comment">// library</span></div><div class="line">apply plugin: <span class="string">'com.android.library'</span></div></pre></td></tr></table></figure>
<p>我们<code>apply plugin</code>之后，如果对应的plugin接受配置，我们就可以按照plugin的要求进行配置。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    <span class="comment">// 以及这里面的一大堆配置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了前面的内容，我们来分析一下<code>apply plugin</code>之后发生了什么。<br>基于<code>com.android.tools.build:gradle:2.2.2</code>分析。</p>
<p>在源码的gradle目录下，我们可以看到<code>resources/META-INF/gradle-plugins</code>目录下存在一些以.properties结尾的文件。<br>这些文件就是我们前面<code>apply plugin: xxx</code>的名字，每个配置文件里的内容说明引入该plugin相当于引入哪个具体的文件。<br>在这个系列的文章里，我们主要关注两个插件，<br><code>com.android.application</code>和<code>com.android.library</code></p>
<p><code>com.android.application.properties</code>里的内容为:<br><code>implementation-class=com.android.build.gradle.AppPlugin</code></p>
<p><code>com.android.library.properties</code>里的内容为:<br><code>implementation-class=com.android.build.gradle.LibraryPlugin</code></p>
<p>这个就指明了我们要研究的类；<br>application插件对应<code>com.android.build.gradle.AppPlugin</code>类<br>library插件对应<code>com.android.build.gradle.LibraryPlugin</code>类</p>
<p>好了，这篇简述就到此为止了，接下来分几篇来研究整个AndroidPlugin流程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2017/03/01/Groovy&Gradle入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/Groovy&Gradle入门/" itemprop="url">Groovy & Gradle 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T00:00:00+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><p><strong>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>单引号’’中的内容严格对应Java中的String，不对$符号进行转义</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">//输出就是I am $ dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>双引号””的内容则和脚本语言的处理有点像，如果字符中有<em>$</em>符的话，则它会<strong>$表达式</strong>先求值。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doubleQuoteWithoutDollar = <span class="string">"I am one dollar"</span> <span class="comment">//输出 I am one dollar</span></div><div class="line"><span class="keyword">def</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">def</span> doubleQuoteWithDollar = <span class="string">"I am $x dolloar"</span> <span class="comment">//输出I am 1 dolloar</span></div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>调用的时候可以不加括号</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(<span class="string">"test"</span>) ----&gt;  println <span class="string">"test"</span></div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getString()&#123;</div><div class="line">	<span class="comment">//代码的最后一句是返回值</span></div><div class="line">  <span class="string">"Hello World!"</span></div><div class="line">  <span class="comment">// 也可以使用return，和Java中普通函数一样</span></div><div class="line">	<span class="comment">// return "Hello World!"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h3><p>是一种数据类型，它代表了一段可执行的代码（类比Java的匿名内部类，可以被称为匿名函数）。其外形如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> closure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..</span></div><div class="line">    String param1, <span class="keyword">int</span> param2</div><div class="line">    -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码</span></div><div class="line">    println <span class="string">"this is codes, $param1, $param2"</span> <span class="comment">//这是代码，最后一句是返回值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简而言之，Closure的定义格式是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> closure = &#123;params -&gt; codes&#125;  <span class="comment">// or</span></div><div class="line"><span class="keyword">def</span> closure = &#123;codes&#125;  <span class="comment">// no params ,so  no '-&gt;'</span></div></pre></td></tr></table></figure>
<p>闭包定义好后，要调用它的方法就是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">closure.call(params) </div><div class="line"><span class="comment">// 下面的方式也可以（groovy 的语法糖）</span></div><div class="line">closure(params)</div></pre></td></tr></table></figure>
<p><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> greeting = &#123; <span class="string">"Hello, $it!"</span> &#125;</div><div class="line"><span class="keyword">assert</span> greeting(<span class="string">'XiaoKa'</span>) == <span class="string">'Hello, XiaoKa!'</span></div></pre></td></tr></table></figure>
<p><strong>Groovy中，调用函数时可以省略圆括号，当然，对于函数的参数里包含闭包同样适用。</strong></p>
<p>比如对于下面这个方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 就可以如下方式调用</span></div><div class="line"><span class="keyword">def</span> testList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></div><div class="line">testList.each &#123;</div><div class="line">  println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个地方要记得，对于看gradle的代码很有帮助</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast&#123;</div><div class="line">  println <span class="string">'Hello World!'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码应该是</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast(&#123;</div><div class="line">  println <span class="string">'Hello World!'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Gradle-基于3-2-1版本"><a href="#Gradle-基于3-2-1版本" class="headerlink" title="Gradle (基于3.2.1版本)"></a>Gradle (基于3.2.1版本)</h2><p>Gradle是什么:</p>
<p><strong>Gradle是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件(Plugin)的方式来完成的。</strong></p>
<h3 id="Gradle工作流程"><a href="#Gradle工作流程" class="headerlink" title="Gradle工作流程"></a>Gradle工作流程</h3><p><img src="/img/gradle/gradle.png" alt="img"></p>
<p>可以看出，Gradle工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段(Initiliazation phase):对Android项目而言，就是evaluate <code>settings.gradle</code>，并将每个Project内的build.gradle转化为Project对象。</li>
<li>Configration阶段:配置对应的Project对象，<code>build.gradle</code>中有关build的代码将会被执行。Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>
<li>最后一个阶段就是执行阶段: 我们可以通过给<code>gradle</code>传递相应的命令来执行相应的task。</li>
</ul>
<h3 id="写Gradle代码"><a href="#写Gradle代码" class="headerlink" title="写Gradle代码"></a>写Gradle代码</h3><p>Gradle dsl api 文档: <a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a></p>
<p>Gradle基于Groovy，Groovy又基于Java。所以，Gradle执行的时候和Groovy一样，会把脚本转换成Java对象。<br>Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p>
<ul>
<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project对象：每一个build.gradle会转换成一个Project对象。</li>
<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>
</ul>
<p>当我们执行gradle的时候，gradle首先是按顺序解析各个gradle文件。这里边就有所谓的顺序问题。这里看一下下面的文档，里面提到的生命周期就是说明这个顺序的。</p>
<p><strong>Lifecycle</strong></p>
<p>There is a one-to-one relationship between a Project and a build.gradle file. During build initialisation, Gradle assembles a Project object for each project which is to participate in the build, as follows:</p>
<ul>
<li>Create a <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> instance for the build.</li>
<li>Evaluate the settings.gradle script, if present, against the <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> object to configure it.</li>
<li>Use the configured <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> object to create the hierarchy of Project instances.</li>
<li>Finally, evaluate each Project by executing its build.gradle file, if present, against the project. The projects are evaluated in breadth-wise order, such that a project is evaluated before its child projects. This order can be overridden by calling <code>Project.evaluationDependsOnChildren()</code> or by adding an explicit evaluation dependency using <code>Project.evaluationDependsOn(java.lang.String).</code></li>
</ul>
<p>Project和<code>build.gradle</code>文件是一一对应的。在build初始化阶段，Gradle为每一个参与Build的project创建一个<code>Project</code>对象。</p>
<ul>
<li>为此次build创建一个<code>Settings</code>实例</li>
<li>Evaluate <code>settings.gradle</code>脚本，如果存在，修改前面<code>Settings</code>实例的属性</li>
<li>根据前面配置过的<code>Settings</code>实例创建<code>Project</code>实例的关系图</li>
<li>最后，通过执行它的<code>build.gradle</code>文件来evaluate每个Project。这个evaluate按照广度优先的顺序，这样可以让子Project在父Project之后evaluate。这个顺序也可以修改。</li>
</ul>
<h4 id="Project对象"><a href="#Project对象" class="headerlink" title="Project对象"></a>Project对象</h4><p>每一个build.gradle文件都会转换成一个Project对象。在Gradle术语中，Project对象对应的是<strong>Build Script</strong>。</p>
<p><strong>Build scripts are code</strong></p>
<p>Project包含若干Tasks。另外，由于Project对应具体的工程，所以需要为Project加载所需要的插件(<code>apply plugin: &#39;xxx&#39;</code>)。其实，一个Project包含多少Task往往是插件决定的。</p>
<p>所以，在Project中，我们要:</p>
<ul>
<li>加载插件。</li>
<li>配置插件的行为，就相当于设置配置文件</li>
</ul>
<p>Project API 文档: </p>
<p><strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong></p>
<ol>
<li>加载插件</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span>    &lt;==如果是编译Library，则加载此插件</div><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span>  &lt;==如果是编译Android APP，则加载此插件</div></pre></td></tr></table></figure>
<p>这是每个Android项目都会见到的代码，这个代码调用<code>apply</code>函数，看一下上面的文档，在<code>Method Summary</code>最底部才能看到<code>apply</code>函数，原来是继承自<code>PluginAware</code>接口。</p>
<p><img src="/img/gradle/apply.png" alt="PluginAware apply方法"></p>
<p>那么，上面那个<code>apply</code>方法是上图所示的第几个方法呢？点击查看详细情况，发现第三个<code>apply</code>函数的解释是:</p>
<p>The following options are available:</p>
<ul>
<li>from: A script to apply. Accepts any path supported by Project.uri(Object).</li>
<li>plugin: The id or implementation class of the plugin to apply.</li>
<li>to: The target delegate object or objects. The default is this plugin aware object. Use this to configure objects other than this object.</li>
</ul>
<p>除了最常见的<code>apply plugin: &#39;xxx&#39;</code>,我们经常使用的<code>apply from: &#39;xxx&#39;</code>也在此。</p>
<p><code>apply plugin: &#39;xxx&#39;</code>加载二进制插件，也就是把对应的jar包下载到了本地。至于我们使用的<code>apply from: &#39;xxx&#39;</code>就是加载对应的文件。</p>
<ol>
<li>配置属性</li>
</ol>
<p>这一点大家只要去看对应plugin的文档即可，文档内提到有哪些属性，则就可以配置哪些属性。</p>
<p>Gradle官方提供的plugin都可以在这里找到对应的文档（比如我们日常用的plugin: ‘maven’）<br><strong><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="external">https://docs.gradle.org/current/userguide/userguide.html</a></strong></p>
<p>Android library和application文档见:<br><strong><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="external">http://google.github.io/android-gradle-dsl/current/index.html</a></strong></p>
<p>其他的第三方plugin,则直接找他们的文档即可。</p>
<p>Project 的一些其它说明:</p>
<h5 id="Extra-属性"><a href="#Extra-属性" class="headerlink" title="Extra 属性"></a>Extra 属性</h5><p>所有额外的属性都需要通过命名空间<code>ext</code>来定义。一旦额外属性被定义了，它可以被所属对象直接访问(读写)(在Project中定义的话，就可以在Project，Task和子Project中访问了)<br>只有初始声明的时候需要命名空间。(当然，如果和其它属性重名还需要全称来指定)</p>
<p>All extra properties must be defined through the <code>ext</code> namespace. Once an extra property has been defined,<br>it is available directly on the owning object (in the below case the Project, Task, and sub-projects respectively) and<br>can be read and updated. Only the initial declaration that needs to be done via the namespace.</p>
<p>最后就是查找顺序，放在这里供大家参考，就不翻译了。</p>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p>A project has 5 property ‘scopes’, which it searches for properties. You can access these properties by name in your build file, or by calling the project’s Project.property(java.lang.String) method. The scopes are:</p>
<ul>
<li>The <code>Project</code> object itself. This scope includes any property getters and setters declared by the Project implementation class. For example, Project.getRootProject() is accessible as the rootProject property. The properties of this scope are readable or writable depending on the presence of the corresponding getter or setter method.</li>
<li>The <code>extra</code> properties of the project. Each project maintains a map of extra properties, which can contain any arbitrary name -&gt; value pair. Once defined, the properties of this scope are readable and writable. See extra properties for more details.</li>
<li>The <code>extensions</code> added to the project by the plugins. Each extension is available as a read-only property with the same name as the extension.</li>
<li>The <code>convention</code> properties added to the project by the plugins. A plugin can add properties and methods to a project through the project’s Convention object. The properties of this scope may be readable or writable, depending on the convention objects.</li>
<li>The tasks of the project. A task is accessible by using its name as a property name. The properties of this scope are read-only. For example, a task called compile is accessible as the compile property.</li>
<li>The extra properties and convention properties inherited from the project’s parent, recursively up to the root project. The properties of this scope are read-only.<br>When reading a property, the project searches the above scopes in order, and returns the value from the first scope it finds the property in. If not found, an exception is thrown. See Project.property(java.lang.String) for more details.</li>
</ul>
<p>When writing a property, the project searches the above scopes in order, and sets the property in the first scope it finds the property in. If not found, an exception is thrown. See Project.setProperty(java.lang.String, java.lang.Object) for more details.</p>
<h5 id="Dynamic-Methods"><a href="#Dynamic-Methods" class="headerlink" title="Dynamic Methods"></a>Dynamic Methods</h5><p>A project has 5 method ‘scopes’, which it searches for methods:</p>
<ul>
<li>The <code>Project</code> object itself.</li>
<li>The build file. The project searches for a matching method declared in the build file.</li>
<li>The <code>extensions</code> added to the project by the plugins. Each extension is available as a method which takes a closure or Action as a parameter.</li>
<li>The <code>convention</code> methods added to the project by the plugins. A plugin can add properties and method to a project through the project’s Convention object.</li>
<li>The tasks of the project. A method is added for each task, using the name of the task as the method name and taking a single closure or Action parameter. The method calls the Task.configure(groovy.lang.Closure) method for the associated task with the provided closure. For example, if the project has a task called compile, then a method is added with the following signature: void compile(Closure configureClosure).</li>
<li>The methods of the parent project, recursively up to the root project.</li>
<li>A property of the project whose value is a closure. The closure is treated as a method and called with the provided parameters. The property is located as described above.</li>
</ul>
<p>参考: <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">深入理解Android之Gradle</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/12/10/OkHttp源码解析-(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/10/OkHttp源码解析-(下)/" itemprop="url">OkHttp源码解析-(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T00:00:00+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇的主要内容就是解析这一个个拦截器，所以重新将图放在这里。</p>
<p><img src="/img/okhttp/OkHttp3.4.1-interceptors.jpg" alt=""></p>
<p>图中存在用户自定义的<code>Interceptor</code>对象，这一部分我们忽略，剩下的<code>Interceptor</code>对象还有如下几个：</p>
<ol>
<li>RetryAndFollowUpInterceptor: 失败重试以及重定向</li>
<li>BridgeInterceptor: 用户友好代码和网络友好代码之间的转化。</li>
<li>CacheInterceptor: 读取缓存直接返回、更新缓存</li>
<li>ConnectInterceptor: 和服务器建立连接</li>
<li>CallServerInterceptor: 向服务器发送请求数据、从服务器读取响应数据的</li>
</ol>
<p>第一个分析<code>RetryAndFollowUpInterceptor</code>这个<code>Interceptor</code>对象。</p>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>作为网络框架，意外不可避免，尤其是外部环境导致的意外，这个时候要有合理的恢复策略，同时在HTTP的世界中，还存在服务端修改了域名，旧的域名要通过重定向访问到新的域名的情况。对于框架来说，异常和重定向都是需要重新请求网络的，就在这个拦截器都给处理了。</p>
<h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor()"></a>interceptor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request request = chain.request();</div><div class="line"></div><div class="line">  streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">  Response priorResponse = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (canceled) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</div><div class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></div><div class="line">      <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</div><div class="line">        <span class="keyword">throw</span> e.getLastConnectException();</div><div class="line">      &#125;</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></div><div class="line">      <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</div><div class="line">      <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">      <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">        streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">        streamAllocation.release();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">    <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .priorResponse(priorResponse.newBuilder()</div><div class="line">                  .body(<span class="keyword">null</span>)</div><div class="line">                  .build())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">// 将服务端返回的消息转换为新的Request</span></div><div class="line">    <span class="comment">// 比如服务端返回301，会在Header头有Location字段告诉你要跳转到哪里。</span></div><div class="line">    Request followUp = followUpRequest(response); </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    closeQuietly(response.body());</div><div class="line">	<span class="comment">// 不会无限的重定向跟踪，防止环形重定向或者造成攻击</span></div><div class="line">    <span class="comment">// MAX_FOLLOW_UPS的次数是20</span></div><div class="line">    <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">          client.connectionPool(), createAddress(followUp.url()), callStackTrace);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</div><div class="line">          + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request = followUp;</div><div class="line">    priorResponse = response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先构造了<code>StreamAllocation</code>对象，该对象将三个实体的关系联系起来了。分别是</p>
<ul>
<li>Connections: 物理socket链接到远端服务 </li>
<li>Streams: 逻辑上的HTTP request/response对，在Connections层之上。</li>
<li>Calls: 逻辑上的流的序列，通常是一个初始请求和接下来的跳转请求。</li>
</ul>
<p>然后，尝试从服务端获取请求，获取请求之后处理请求，通过<code>followUpRequest()</code>方法，这个方法是这个拦截器处理的核心。如果获取响应失败，则会尝试恢复请求，这个处理内容在<code>recover()</code>方法内，其他的一些错误处理我这里就不解析了。那我们来看一看<code>followUpRequest()</code>方法。</p>
<h4 id="followUpRequest"><a href="#followUpRequest" class="headerlink" title="followUpRequest()"></a>followUpRequest()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Figures out the HTTP request to make in response to receiving &#123;<span class="doctag">@code</span> userResponse&#125;. This will</div><div class="line"> * either add authentication headers, follow redirects or handle a client request timeout. If a</div><div class="line"> * follow-up is either unnecessary or not applicable, this returns null.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">followUpRequest</span><span class="params">(Response userResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">  Connection connection = streamAllocation.connection();</div><div class="line">  Route route = connection != <span class="keyword">null</span></div><div class="line">      ? connection.route()</div><div class="line">      : <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">int</span> responseCode = userResponse.code();</div><div class="line"></div><div class="line">  <span class="keyword">final</span> String method = userResponse.request().method();</div><div class="line">  <span class="keyword">switch</span> (responseCode) &#123;</div><div class="line">   <span class="comment">// HTTP Status-Code 407: Proxy Authentication Required.</span></div><div class="line">   <span class="comment">// 需要代理，则调用创建okhttp对象的时候设置的代理对象</span></div><div class="line">    <span class="keyword">case</span> HTTP_PROXY_AUTH:</div><div class="line">      Proxy selectedProxy = route != <span class="keyword">null</span></div><div class="line">          ? route.proxy()</div><div class="line">          : client.proxy();</div><div class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</div><div class="line">    <span class="comment">//  HTTP Status-Code 401: Unauthorized.</span></div><div class="line">    <span class="comment">// 需要身份验证，则调用创建okhttp对象的时候设置的验证对象，加入对应的信息</span></div><div class="line">    <span class="keyword">case</span> HTTP_UNAUTHORIZED:</div><div class="line">      <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</div><div class="line"></div><div class="line">    <span class="keyword">case</span> HTTP_PERM_REDIRECT:</div><div class="line">    <span class="keyword">case</span> HTTP_TEMP_REDIRECT:</div><div class="line">      <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></div><div class="line">      <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></div><div class="line">      <span class="keyword">if</span> (!method.equals(<span class="string">"GET"</span>) &amp;&amp; !method.equals(<span class="string">"HEAD"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// fall-through</span></div><div class="line">    <span class="keyword">case</span> HTTP_MULT_CHOICE:</div><div class="line">    <span class="keyword">case</span> HTTP_MOVED_PERM:</div><div class="line">    <span class="keyword">case</span> HTTP_MOVED_TEMP:</div><div class="line">    <span class="keyword">case</span> HTTP_SEE_OTHER:</div><div class="line">      <span class="comment">// Does the client allow redirects?</span></div><div class="line">      <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// Header 头中读取Location字段</span></div><div class="line">      String location = userResponse.header(<span class="string">"Location"</span>);</div><div class="line">      <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// 通过Location字段的值构造新的请求的url</span></div><div class="line">      HttpUrl url = userResponse.request().url().resolve(location);</div><div class="line"></div><div class="line">      <span class="comment">// Don't follow redirects to unsupported protocols.</span></div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></div><div class="line">      <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</div><div class="line">      <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Most redirects don't include a request body.</span></div><div class="line">      Request.Builder requestBuilder = userResponse.request().newBuilder();</div><div class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</div><div class="line">        <span class="comment">// 除了PROPFIND(WebDAV用的)请求，其他请求都要转为GET请求</span></div><div class="line">        <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</div><div class="line">          requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</div><div class="line">          requestBuilder.method(method, requestBody);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!maintainBody) &#123;</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></div><div class="line">      <span class="comment">// is potentially annoying to the application layer since they have no</span></div><div class="line">      <span class="comment">// way to retain them.</span></div><div class="line">      <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</div><div class="line">        requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> requestBuilder.url(url).build();</div><div class="line"></div><div class="line">    <span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</div><div class="line">      <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></div><div class="line">      <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></div><div class="line">      <span class="comment">// repeat the request (even non-idempotent ones.)</span></div><div class="line">      <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 超时返回原始的请求，就代表重新请求</span></div><div class="line">      <span class="keyword">return</span> userResponse.request();</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的解析都在代码中以注释的形式出现了。<br>到这里，这个Interceptor就解析完毕了，我们来看看文章最开头链上下一个Interceptor:</p>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>作为框架，不可能要求所有使用者都对HTTP协议理解的很深刻。所以，框架需要将HTTP协议中约定的信息加入其中，要让使用者尽可能少的处理HTTP协议的细节，这就是这个Interceptor的任务。</p>
<h4 id="interceptor-1"><a href="#interceptor-1" class="headerlink" title="interceptor()"></a>interceptor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request userRequest = chain.request();</div><div class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line"></div><div class="line">  RequestBody body = userRequest.body();</div><div class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</div><div class="line">    MediaType contentType = body.contentType();</div><div class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 从这里可以看出，HTTP请求头的Content-Length和Transfer-Encoding是互斥的</span></div><div class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</div><div class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</div><div class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</div><div class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></div><div class="line">  <span class="comment">// the transfer stream.</span></div><div class="line">  <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// 不指定Accept-Encoding请求头，默认使用gzip，压缩数据</span></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    transparentGzip = <span class="keyword">true</span>;</div><div class="line">    requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</div><div class="line">  <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 用户设置了UA,这里就不能覆盖了，否则使用当前okhttp版本作为UA</span></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line"></div><div class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</div><div class="line"></div><div class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</div><div class="line">      .request(userRequest);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (transparentGzip</div><div class="line">      &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</div><div class="line">      &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</div><div class="line">      <span class="comment">// 因为响应式gzip编码，所以需要先解压</span></div><div class="line">    GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</div><div class="line">    Headers strippedHeaders = networkResponse.headers().newBuilder()</div><div class="line">        .removeAll(<span class="string">"Content-Encoding"</span>)</div><div class="line">        .removeAll(<span class="string">"Content-Length"</span>)</div><div class="line">        .build();</div><div class="line">    responseBuilder.headers(strippedHeaders);</div><div class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> responseBuilder.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里理解起来很容易，看代码中的注释即可，接下来看下一个Interceptor:</p>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>网络请求毕竟是一个缓慢的操作，所以，可以通过缓存来加速，但是，不能所有都缓存，也不能什么情况下都从缓存中拿数据，这里就是处理这个逻辑的地方。</p>
<h4 id="intercept"><a href="#intercept" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">      ? cache.get(chain.request())</div><div class="line">      : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">  <span class="comment">// 根据HTTP的Date|Expires|Last-Modified|ETag|Age头来确定对应的策略</span></div><div class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">  Request networkRequest = strategy.networkRequest;</div><div class="line">  Response cacheResponse = strategy.cacheResponse;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">    cache.trackResponse(strategy);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></div><div class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">        .request(chain.request())</div><div class="line">        .protocol(Protocol.HTTP_1_1)</div><div class="line">        .code(<span class="number">504</span>)</div><div class="line">        .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">        .body(Util.EMPTY_RESPONSE)</div><div class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we don't need the network, we're done.</span></div><div class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response networkResponse = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    networkResponse = chain.proceed(networkRequest);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></div><div class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></div><div class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// HTTP Status-Code 304: Not Modified. </span></div><div class="line">    <span class="comment">// 存在缓存，服务端还返回这个HTTP状态码</span></div><div class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">      Response response = cacheResponse.newBuilder()</div><div class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .networkResponse(stripBody(networkResponse))</div><div class="line">          .build();</div><div class="line">      networkResponse.body().close();</div><div class="line"></div><div class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">      cache.trackConditionalCacheHit();</div><div class="line">      cache.update(cacheResponse, response);</div><div class="line">      <span class="keyword">return</span> response;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      closeQuietly(cacheResponse.body());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response response = networkResponse.newBuilder()</div><div class="line">      .cacheResponse(stripBody(cacheResponse))</div><div class="line">      .networkResponse(stripBody(networkResponse))</div><div class="line">      .build();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpHeaders.hasBody(response)) &#123;</div><div class="line">    CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);</div><div class="line">    response = cacheWritingResponse(cacheRequest, response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要通过<code>CacheStrategy</code>类来管理Cache的储存策略，比如要不要保存Cache，保存Cache的超时时间等等，详细内容看这个类即可。<br>如果没网，不存在Cache就返回504状态码的响应，否则返回cache响应。<br>通过网络请求获取响应。响应的状态码304的情况下，还存在缓存，则更新缓存，返回对应的响应。<br>最后，不存在缓存的情况下去除cacheResponse和networkResponse的body，返回通过请求获取的响应。</p>
<p>接着看下一个Interceptor:</p>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>这个Interceptor的作用就是建立与服务端的连接，为什么将连接服务器和服务器之间的交互分开呢？我觉得因为提供的networkInterceptors对象，这个对象给了框架使用者这样一种能力，在连接到服务器的时候做一些需要的操作（我暂时没遇到这样的需求，所以对这里理解不深，大家有想法的可以在评论里告诉我）</p>
<h4 id="intercept-1"><a href="#intercept-1" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">  Request request = realChain.request();</div><div class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></div><div class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">  HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">  RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得分析<code>RetryAndFollowUpInterceptor</code>过程中出现的<code>StreamAllocation</code>对象吗？这里又出现，根据前面说的，HttpCodec就是一个Stream，RealConnection就是Connection。那也就意味着，逻辑的HTTP请求响应是HttpCodec负责处理的。</p>
<p>这里就简单分析一下<code>HttpCodec</code>,对它有个具体的认识，到分析下一个Interceptor的时候，才不会那么头疼。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Encodes HTTP requests and decodes HTTP responses. */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpCodec</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The timeout to use while discarding a stream of input data. Since this is used for connection</div><div class="line">   * reuse, this timeout should be significantly less than the time it takes to establish a new</div><div class="line">   * connection.</div><div class="line">   */</div><div class="line">  <span class="keyword">int</span> DISCARD_STREAM_TIMEOUT_MILLIS = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns an output stream where the request body can be streamed. */</span></div><div class="line">  <span class="function">Sink <span class="title">createRequestBody</span><span class="params">(Request request, <span class="keyword">long</span> contentLength)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/** This should update the HTTP engine's sentRequestMillis field. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Flush the request to the underlying socket. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Read and return response headers. */</span></div><div class="line">  Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a stream that reads the response body. */</span></div><div class="line">  <span class="function">ResponseBody <span class="title">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.</div><div class="line">   * That may happen later by the connection pool thread.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>HttpCodec</code>是一个接口，为什么是一个接口呢？因为HTTP协议的兼容性问题，HTTP现在已经存在两种实现了，分为HTTP1和HTTP2，HTTP协议的不同，当然，进行这些操作的实现方式也不一样，所以，通过接口隔离具体协议实现方式的不同。当然，具体的实现在<code>streamAllocation.newStream()</code>这里，通过连接到服务器，服务器会返回接受的协议，发现服务端接受”h2”，则使用<code>Http2Codec</code>，否则使用<code>Http1Codec</code></p>
<p>好了，终于到了最后一个Interceptor:</p>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>前面的Interceptor做了这么多铺垫，就等着最后一个Interceptor完成最后一步，向服务端发送请求，从服务端获取请求。</p>
<h4 id="intercept-2"><a href="#intercept-2" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();</div><div class="line">  StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();</div><div class="line">  Request request = chain.request();</div><div class="line"></div><div class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line">  <span class="comment">// 发送request header</span></div><div class="line">  httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="comment">// 发送request body</span></div><div class="line">    Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">    request.body().writeTo(bufferedRequestBody);</div><div class="line">    bufferedRequestBody.close();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 完成request</span></div><div class="line">  httpCodec.finishRequest();</div><div class="line">  <span class="comment">// 读取response header</span></div><div class="line">  Response response = httpCodec.readResponseHeaders()</div><div class="line">      .request(request)</div><div class="line">      .handshake(streamAllocation.connection().handshake())</div><div class="line">      .sentRequestAtMillis(sentRequestMillis)</div><div class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">      .build();</div><div class="line"></div><div class="line">  <span class="keyword">int</span> code = response.code();</div><div class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></div><div class="line">    response = response.newBuilder()</div><div class="line">        .body(Util.EMPTY_RESPONSE)</div><div class="line">        .build();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    response = response.newBuilder()</div><div class="line">        .body(httpCodec.openResponseBody(response))</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">      || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">    streamAllocation.noNewStreams();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">        <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要流程是:</p>
<ol>
<li>发送request header</li>
<li>存在request body,发送给服务端</li>
<li>完成request</li>
<li>读取服务端response header，生成Response对象</li>
<li>存在response body,则将body添加到上一步生成的Response对象里</li>
</ol>
<p>好了，到这里我们就把Interceptor链给分析完毕了。然后Response对象就一层层的返回到之前的Interceptors里了。如果前面的Interceptor关心Response，就重新进行这样的链式处理，否则就返回给我们调用网络请求的地方，这样我们就拿到了需要的Response对象。</p>
<p>通过我们的分析，可以看出，这个责任链把功能分层分的淋漓尽致，需要什么功能，加一个专门的Interceptor即可，了解到了这样一种简洁干净的设计，以后写代码的时候就可以借鉴一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/12/03/OkHttp源码解析-(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/03/OkHttp源码解析-(上)/" itemprop="url">OkHttp源码解析-(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-03T00:00:00+08:00">
                2016-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直都知道Retrofit-OkHttp-Okio是Square公司封装的用于网络请求的大杀器，项目中也往往都在用Retrofit，看过我之前的文章的朋友应该看到过我的Retrofit源码解析系列， 但是一直没空往下继续深入，去解析OkHttp和Okio，毕竟Retrofit2.0本身就是搭建于OkHttp之上的。</p>
<p>老规矩，先讲一下这个库如何用，最后渐渐的一步步走到这个库的处理过程。</p>
<h3 id="如何使用OkHttp"><a href="#如何使用OkHttp" class="headerlink" title="如何使用OkHttp"></a>如何使用OkHttp</h3><p>官方文档很详细的解释了如何使用OkHttp，我们只要一步步跟着就可以了。至于OkHttp优点，或者说为什么使用OkHttp我在这里就略过不提，相信你在看源码的过程中会有自己的理解。</p>
<p>大家在平常的http请求中，最常见的就是使用GET和POST请求，所以，官方Demo也就主要描述了如何处理这两种请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function">String <span class="title">get</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">      .url(url)</div><div class="line">      .build();</div><div class="line"></div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  <span class="keyword">return</span> response.body().string();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</div><div class="line">    = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</div><div class="line">    </div><div class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  RequestBody body = RequestBody.create(JSON, json);</div><div class="line">  Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">      .url(url)</div><div class="line">      .post(body)</div><div class="line">      .build();</div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  <span class="keyword">return</span> response.body().string();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看出，想要完成一次请求需要以下几个过程：</p>
<ol>
<li>构造<code>OkHttpClient</code>对象</li>
<li>创建Request</li>
<li>调用<code>OkHttpClient</code>对象的<code>newCall()</code>方法构造<code>Call</code>对象</li>
<li>调用<code>Call</code>对象的<code>execute()</code>方法获取<code>Response</code></li>
</ol>
<h3 id="OkHttp-整体调用流程"><a href="#OkHttp-整体调用流程" class="headerlink" title="OkHttp 整体调用流程"></a>OkHttp 整体调用流程</h3><p><img src="/img/okhttp/OkHttp3.4.1.jpg" alt=""></p>
<p>这次先看图，有了图，跟代码的时候才不会在代码中迷失。</p>
<h3 id="OkHttp源码解读"><a href="#OkHttp源码解读" class="headerlink" title="OkHttp源码解读"></a>OkHttp源码解读</h3><h4 id="OkHttpClient对象"><a href="#OkHttpClient对象" class="headerlink" title="OkHttpClient对象"></a><code>OkHttpClient</code>对象</h4><p>参考流程图，我们先需要一个<code>OkHttpClient</code>对象，这个对象需要许多参数，所以用建造者模式构建，当然，每个参数都提供了默认值，也可以直接用<code>OkHttpClient</code>的构造函数来使用默认的实现。</p>
<p>这是各个参数的默认值，需要修改的通过Builder直接修改即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</div><div class="line">  protocols = DEFAULT_PROTOCOLS;</div><div class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">  proxySelector = ProxySelector.getDefault();</div><div class="line">  cookieJar = CookieJar.NO_COOKIES;</div><div class="line">  socketFactory = SocketFactory.getDefault();</div><div class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">  certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">  proxyAuthenticator = Authenticator.NONE;</div><div class="line">  authenticator = Authenticator.NONE;</div><div class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</div><div class="line">  dns = Dns.SYSTEM;</div><div class="line">  followSslRedirects = <span class="keyword">true</span>;</div><div class="line">  followRedirects = <span class="keyword">true</span>;</div><div class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</div><div class="line">  connectTimeout = <span class="number">10_000</span>;</div><div class="line">  readTimeout = <span class="number">10_000</span>;</div><div class="line">  writeTimeout = <span class="number">10_000</span>;</div><div class="line">  pingInterval = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Call对象"><a href="#Call对象" class="headerlink" title="Call对象"></a><code>Call</code>对象</h4><p>接下来就需要发请求了，发请求需要一个<code>Call</code>对象, 我们通过<code>newCall()</code>方法获取这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，真正调用的<code>Call</code>实现类是<code>RealCall</code>这个类,默认情况下，这个<code>RealCall</code>对象的<code>forWebSocket</code>属性为false。</p>
<h4 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h4><p>构造完<code>Call</code>对象，通过<code>Call</code>对象的<code>execute()</code>方法同步的执行请求或者<code>enqueue()</code>方法异步的执行请求。</p>
<p>这里看一下图，会感觉图中的线在这里很密集，而且<code>Dispatcher</code>对象的线会指给这么多的方法，等我们进入源码中，就可以仔细了解了。</p>
<h5 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall execute()"></a>RealCall execute()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">    Response result = getResponseWithInterceptorChain();</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="RealCall-enqueue"><a href="#RealCall-enqueue" class="headerlink" title="RealCall enqueue()"></a>RealCall enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里面的方法都会调用<code>Dispatcher</code>对象的方法，所以，图中从<code>Dispatcher</code>对象中发出3条线，代表对应方法执行过程中调用<code>Dispatcher</code>对象的方法。</p>
<p>虽然<code>Dispatcher</code>对象在同步和异步的请求中都有它身影的出现，<br>但是，它主要作用是在异步请求中，开线程池执行异步请求，并用队列保持准备执行的请求。</p>
<h5 id="Dispatcher-enqueue"><a href="#Dispatcher-enqueue" class="headerlink" title="Dispatcher enqueue()"></a>Dispatcher enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">    runningAsyncCalls.add(call);  <span class="comment">// runningAsyncCalls是一个队列</span></div><div class="line">    executorService().execute(call); <span class="comment">// executorService是一个线程池</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    readyAsyncCalls.add(call); <span class="comment">// readyAsyncCalls是一个队列</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在同步请求中，它的作用是保存当前正在执行的请求，那么为什么要进行这样一个操作呢？</p>
<h5 id="Dispatcher-executed"><a href="#Dispatcher-executed" class="headerlink" title="Dispatcher executed()"></a>Dispatcher executed()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</div><div class="line">  runningSyncCalls.add(call); <span class="comment">// runningSyncCalls是一个队列</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看<code>Dispatcher</code>对象的方法，发现有个<code>cancelAll()</code>方法，原来给用户提供了取消所有请求的操作，那么当前执行的同步请求依旧是要被cancel的，所以，自然要把当前正在执行的同步请求加入其中了。</p>
<h5 id="Dispatcher-cancelAll"><a href="#Dispatcher-cancelAll" class="headerlink" title="Dispatcher cancelAll()"></a>Dispatcher cancelAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (AsyncCall call : readyAsyncCalls) &#123;</div><div class="line">    call.get().cancel();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (AsyncCall call : runningAsyncCalls) &#123;</div><div class="line">    call.get().cancel();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (RealCall call : runningSyncCalls) &#123;</div><div class="line">    call.cancel();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后获取到<code>Response</code>对象的时候，通知<code>Dispatcher</code>请求结束了，<code>Dispatcher</code>就会在队列里移除相应的请求，所以图中<code>Dispatcher</code>对象还有一条线指向<code>Response</code>对象。</p>
<p>重新回到<code>RealCall</code>对象，发现无论同步还是异步请求，获取<code>Response</code>的方式都是通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response response = getResponseWithInterceptorChain();</div></pre></td></tr></table></figure>
<p>这样获取的。</p>
<p>我们通过这个方法就获取了<code>Response</code>对象，说明这个方法为我们做了真正发请求的工作，那么我们先看一张图，看这么复杂的工作，这个方法是如何实现的。</p>
<p><img src="/img/okhttp/OkHttp3.4.1-interceptors.jpg" alt=""></p>
<p>从图中可以看到，这个执行过程像链条一样一环套一环，如果熟悉设计模式，这不就是很好的责任链模式嘛。好了，我们看一下它这里具体做了什么。</p>
<h5 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall getResponseWithInterceptorChain()"></a>RealCall getResponseWithInterceptorChain()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这其中有下面几种拦截器进行操作。</p>
<ol>
<li>在配置 OkHttpClient 时设置的 interceptors；</li>
<li>负责失败重试以及重定向的 RetryAndFollowUpInterceptor；</li>
<li>负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；<br>4.负责读取缓存直接返回、更新缓存的 CacheInterceptor；</li>
<li>负责和服务器建立连接的 ConnectInterceptor；</li>
<li>配置 OkHttpClient 时设置的 networkInterceptors；</li>
<li>负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。</li>
</ol>
<p>可以看到，这个方法最终执行的是<code>RealInterceptorChain</code>对象的<code>process()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">    Connection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">  calls++;</div><div class="line">  </div><div class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !sameConnection(request.url())) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must retain the same host and port"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">  Interceptor interceptor = interceptors.get(index);</div><div class="line">  Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></div><div class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不关心异常状况，核心代码就是如下几行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">    interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">Interceptor interceptor = interceptors.get(index);</div><div class="line">Response response = interceptor.intercept(next);</div></pre></td></tr></table></figure>
<p>在<code>process()</code>的过程中，做了如下几个操作：</p>
<ol>
<li>生成新的<code>RealInterceptorChain</code>对象</li>
<li>按<code>index</code>获取当前interceptors列表中<code>Interceptor</code>对象</li>
<li>调用<code>Interceptor</code>对象的<code>intercept()</code>方法，并将新的<code>RealInterceptorChain</code>传给<code>Interceptor</code>对象。</li>
</ol>
<p>这样，只要<code>Interceptor</code>对象在<code>intercept()</code>方法执行过程中调用<code>Chain</code>对象的<code>proceed()</code>方法，就会调用传给<code>Interceptor</code>对象的下一个<code>RealInterceptorChain</code>对象的<code>proceed()</code>方法。这样，就像上面说的，一条链一样的不停调用。</p>
<p>好了，上半部分的分析暂时就到这里了，下半部分对各个<code>Interceptor</code>进行分析。</p>
<p>参考: <a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/10/11/Jenkins使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/Jenkins使用/" itemprop="url">Jenkins的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T00:00:00+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前提: 使用Git作为公司的版本控制工具，使用GitLab作为对应的服务器</strong></p>
<p>首先安装Jenkins plugins, 下面列出两个关键的Plugins</p>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin" target="_blank" rel="external">GitLab Plugin</a></p>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin" target="_blank" rel="external">Git plugin</a></p>
<h3 id="打包APK"><a href="#打包APK" class="headerlink" title="打包APK"></a>打包APK</h3><p>对于APK的打包，相信大家公司内部都有不同的测试环境，不同的功能需要在不同的测试环境上测试，不同的功能又对应不同的分支，如果开发人员负责根据测试人员的需求打包的话，测试人员麻烦，开发人员也麻烦。程序员一个极好的特质就是懒，那么，这时候，Jenkins提供的<code>This build is parameterized</code>功能就派上了用处。</p>
<p><img src="/img/jenkins/build_params.png" alt=""></p>
<p>勾选了这个选项之后，就可以添加自己需要的参数了，比如:</p>
<p><img src="/img/jenkins/url.png" alt="测试环境地址 "><br><img src="/img/jenkins/git_branch.png" alt="git的分支名称"></p>
<p>记住这个地方填写的<code>name</code>， 这里的名称将会是shell里的变量，使用$来引用对应具体的变量，下面将会看到这些变量的使用。</p>
<p>既然环境和分支都已经可选，第二步是配置Jenkins去哪个地址拉源代码，即SCM配置，如下图:<br><img src="/img/jenkins/scm_git.png" alt=""></p>
<p>可以看到，在<code>Branches to build</code>的地方，我填的内容是<code>*/$git_branch</code>，这个参数就是从前面<code>This build is parameterized</code>位置添加的参数，所以用户填了哪个分支，这里就能拿到用户填写的分支，在Build的时候也就会拉对应分支的代码。</p>
<p>按照我们的意向拉了对应分支的代码，开头所说的另外一个问题，更改对应的环境，当然，可以使用<code>ProductFlavor</code>来解决这个问题，再最后打包的情况下选择对应的<code>ProductFlavor</code>，数量少了还好说，数量多了，就会变得很麻烦。因此，这里在<code>Build Environment</code>的地方，打勾<br><code>Executor shell script on remote host using ssh</code>，如下图<br><img src="/img/jenkins/change_env.png" alt=""></p>
<p>在<code>Pre build script</code>的地方，修改你工程中决定使用哪个环境的文件，这里就可以使用最开头的<code>$url_host</code>那个设定的参数。</p>
<p>当然还有<code>Post build script</code>，需要的话就同样写一段shell来达到你的目的。</p>
<p>有些情况下，你需要获取这次打包对应的git信息，可以看到，每个打包都有一个Git Build Data，这里面有对应的git信息，所以，勾选<code>inject environment variables to the build process</code>即可将对应的信息添加到这次打包的环境变量中。<br>这个需要<a href="https://wiki.jenkins-ci.org/display/JENKINS/EnvInject+Plugin" target="_blank" rel="external">Environment Injector Plugin</a>插件的支持。<br>这里有个问题，就是<code>Evaluated  Groovy Script</code>脚本的执行过程中，使用正常方式无法获取所有的Jenkins环境变量，那么需要使用<code>currentBuild.getEnvironment(currentListener).get(&#39;var&#39;)</code>来获取var的环境变量。currentBuild和currentListener在Evaluated  Groovy Script右边的<code>?</code>说明里</p>
<p><img src="/img/jenkins/build_env_inject.png" alt=""></p>
<p>最后，测试人员肯定希望能下载打包完成的APK，那么在最后的<code>Post-build Actions</code>即可实现该需求。</p>
<p><img src="/img/jenkins/post_build_action.png" alt=""></p>
<p>在<code>Archive the artifacts</code>里面填入打包完成的apk的路径，则Jenkins会以可以下载的形式输出该Apk的链接在对应的打包完成页面。</p>
<h3 id="打包AAR"><a href="#打包AAR" class="headerlink" title="打包AAR"></a>打包AAR</h3><p>打包AAR和打包APK的需求是不同的，对于AAR的输出，一定希望对开发透明，不需要任何人去点一下build，才去打包AAR，这个时候，我们前面安装的GitLab Plugin就十分有用。有了它，我们可以设定触发打包任务的条件:</p>
<p><img src="/img/jenkins/build_trigger.png" alt=""></p>
<p>画红线的URL代表  GitLab WebHook需要回调的URL，即GitLab收到某些事件(push, merge request ..etc)，将会调用该URL，此时将会触发打包。在最下面还有个红线，就是指定相应的分支，在这些分支另在GitLab WebHook回调的时候才进行打包，公司的特殊需求即可在这里定制。</p>
<p>有可能你想流式的打包，也可能你的aar有优先级，换句话说，A aar可能依赖B aar，那么一定要B aar打包完毕后，才能打包A aar，那样的话你就需要下面这个插件<br><a href="https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Trigger+Plugin" target="_blank" rel="external">Jenkins Parameterized Trigger plugin</a><br>这个插件将前一个打包aar的Build Env传给后一个打包aar的过程中，那样，就拥有一致的Build Env了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/05/22/retrofit2.0源码解析(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/22/retrofit2.0源码解析(下)/" itemprop="url">Retrofit2源码分析-(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-22T00:00:00+08:00">
                2016-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  上篇我们主要看了一下Retrofit的设计者对Retrofit1.+版本设计的评价（好的方面和坏的方面），同时也讲了Retrofit2都这些问题时如何解决的，这篇，我们就一起深入去了解一下。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>  一个网络连接需要构造请求，发送请求，处理服务端返回内容三个步骤组成，但是处理服务端返回内容是用库的人的工作，所以一个网络请求库只要做到前两步并将服务端返回内容转化为使用库的人需要的格式即可。</p>
<p>对于这三个步骤，两个版本的区别在于</p>
<h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求:"></a>构造请求:</h4><ol>
<li>Retrofit2新加了<code>@Url</code>注解。</li>
<li>新加了对某个请求单独加入Http请求头，<code>@Headers</code>(用于方法)/<code>@Header</code>(用于函数参数)。</li>
</ol>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求:"></a>发送请求:</h4><ol>
<li>将网络请求交给了OkHttp</li>
</ol>
<h4 id="将服务端返回内容转化为你需要的格式"><a href="#将服务端返回内容转化为你需要的格式" class="headerlink" title="将服务端返回内容转化为你需要的格式:"></a>将服务端返回内容转化为你需要的格式:</h4><ol>
<li>Retrofit2将可以同时拿到返回内容的Header和Body，Retrofit1则不可以</li>
<li>使用Call返回值类型将同步和异步请求统一</li>
<li>可以添加多个Converter</li>
<li>可以添加多个返回值类型的解析机制，在Retrofit2中称为<code>CallAdapterFactory</code>使用<code>addCallAdapterFactory()</code></li>
</ol>
<p>我们接下来跟着官方的例子来看一下这些修改时如何实现的。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里可以看出，通过<code>Retrofit</code>对象的<code>create()</code>方法创建出<code>GithubService</code>接口的实现，然后通过该实现进行网路请求，那么我们看看<code>create()</code>方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </div><div class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,<span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>熟悉Retrofit1的同学可以看出这里有3点不同的地方，不熟悉也没关系，因为相同的地方就是验证接口的有效性和使用动态代理生成接口对应的实现类。接下来讲一下这三点不同。</p>
<ol>
<li>添加了<code>validateEagerly</code>参数，让客户端调用网络请求的时候不需要在反射生成的代理类中才进行初始化;提前初始化，提前验证接口是否合法，不需要在调用时才知道。</li>
<li>添加了一个暂时不用的方法，为以后使用做扩展<code>platform.isDefaultMethod(method)</code>。</li>
<li>将初始化过的方法交给<code>OkHttpCall</code>去执行，执行完后，通过设置的<code>CallAdapter</code>将返回值转化为你要的返回类型对象，当你通过该对象调用它的方法的时候，将把请求交给<code>OkHttp</code>去执行。</li>
</ol>
<p>分开来讲一下，先看第二点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这个方法压根就没有用，所以我不是很了解放在这里一个不需要的方法意义是什么。</p>
<p>再看第一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">   eagerlyValidateMethods(service);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</div><div class="line">  <span class="comment">//和Retrofit1一样，通过反射确定客户端的平台，使用不同的方式处理</span></div><div class="line">  Platform platform = Platform.get();</div><div class="line">  <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</div><div class="line">    <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</div><div class="line">      loadServiceMethod(method);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//和Retrofit1一样，使用Map做了一个缓存，有的话直接取，</span></div><div class="line"><span class="comment">//否则遍历该方法的信息，创建ServiceMethod对象</span></div><div class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">    ServiceMethod result;</div><div class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下第三点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">   OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">   <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p><code>serviceMethod.callAdapter.adapt()</code>方法将<code>Call</code>对象转化为你写的返回值类型对象，即你在接口中所需的除<code>Call&lt;T&gt;</code>类型外，都需要对应的<code>CallAdapter</code>来进行转化。<code>OkHttpCall</code>实现了<code>Call&lt;T&gt;</code>接口，也就是前一篇讲到的，加入了<code>Call&lt;T&gt;</code>返回值类型。默认的<code>CallAdapter</code>支持转化成<code>Call</code>类型对象，如果需要其他的类型，你就需要调用<code>addCallAdapterFactory()</code>方法来添加新类型了。然后通过<code>OkHttp</code>进行网络请求。</p>
<p>到这里大体上就讲完了，接下来就重新回到前面讲的，对一个网络请求的三个步骤进行分析，看看代码中具体是如何实现的（老规矩，忽视不重要的错误处理）。</p>
<h4 id="构造请求-1"><a href="#构造请求-1" class="headerlink" title="构造请求:"></a>构造请求:</h4><p>这一点的重点在<code>ServiceMethod</code>这个类，前面讲到了这个类初始化的地方，那么就从<br><code>new ServiceMethod.Builder(this, method).build()</code>开始。<br>构造函数就初始化了一些类变量，来看一下<code>build()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// </span></div><div class="line">    callAdapter = createCallAdapter();</div><div class="line">    <span class="comment">// 把函数返回值类型中泛型内的类型拿出来，</span></div><div class="line">    <span class="comment">// 比如接口方法中某个方法返回Call&lt;Repo&gt;，这个方法执行结果是Repo</span></div><div class="line">    responseType = callAdapter.responseType();</div><div class="line">    </div><div class="line">    responseConverter = createResponseConverter();</div><div class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">      <span class="comment">//解析定义的Http注解，如GET，HTTP，FormUrlEncoded，Multipart，Headers</span></div><div class="line">      <span class="comment">//如果存在Headers注解，Headers注解内的内容不能为空</span></div><div class="line">      parseMethodAnnotation(annotation);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// parameterAnnotationsArrays = method.getParameterAnnotations(),</span></div><div class="line">	<span class="comment">// 即参数中的注解，二维注解数组Annotation[][]</span></div><div class="line">    <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">    <span class="comment">// ParameterHandler这个类如名字所示，负责处理有注解的函数参数</span></div><div class="line">    parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">      <span class="comment">// parameterType = method.getGenericParameterTypes()</span></div><div class="line">      Type parameterType = parameterTypes[p];</div><div class="line">      <span class="comment">// 这个方法就是检测方法参数类型是否是可以处理的类型</span></div><div class="line">      <span class="comment">// 这个方法可以学到如何遍历所有的参数类型，包括泛型类型参数</span></div><div class="line">	  <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">	            <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</div><div class="line">	                parameterType);</div><div class="line">	          &#125;</div><div class="line"></div><div class="line">      Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">      <span class="comment">// 这里处理Retrofit2定义的所有@Target(PARAMETER)的参数，返回对应的ParameterHandler</span></div><div class="line">      parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>createCallAdapter()</code>，<code>createResponseConverter()</code>这两个方法，这两个方法我们一会再说，按名字理解就是创建<code>CallAdapter</code>和<code>ResponseConverter</code>，这两个东西的作用就是将方法的返回值转化成你要的。</p>
<p>剩下的关键方法都在方法中做了注释，这样，<code>ServiceMethod</code>类对象就生成了。<br>到了这里，先不继续进行，先看一下<code>parseMethodAnnotation(annotation)</code>方法中使用的<code>parseHttpMethodAndPath()</code>方法，这个方法中会做一些验证，这个验证个人觉得有些不好理解，所以放出源代码，并将注释写在方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.httpMethod = httpMethod;</div><div class="line">  <span class="keyword">this</span>.hasBody = hasBody;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value.isEmpty()) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Get the relative URL path and existing query string, if present.</span></div><div class="line">  <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</div><div class="line">  <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// Ensure the query string does not have any named parameters.</span></div><div class="line">    String queryParams = value.substring(question + <span class="number">1</span>);</div><div class="line">    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</div><div class="line">    <span class="keyword">if</span> (queryParamMatcher.find()) &#123;<span class="comment">// url中?之后的的String不允许存在"&#123;&#125;"</span></div><div class="line">      <span class="keyword">throw</span> methodError(<span class="string">"URL query string \"%s\" must not have replace block. "</span></div><div class="line">          + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.relativeUrl = value;</div><div class="line">  <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了， 这点不好理解的地方也过去了。既然生成了<code>ServiceMethod</code>，那么我们继续往下看：<br>构造函数生成了<code>OkHttpCall</code>对象，最后，通过<code>ServiceMethod</code>的<code>CallAdapter</code>对象将<code>OkHttpCall</code>对象转化为你在网络请求接口中声明的返回值类型。</p>
<p>在这里，我们再看一下上面提到但没分析的那两个方法<code>createCallAdapter()</code>和<code>createResponseConverter()</code>。先看<code>createCallAdapter()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> CallAdapter&lt;?&gt; createCallAdapter() &#123;</div><div class="line">  <span class="comment">// 返回方法声明的返回类型</span></div><div class="line">  Type returnType = method.getGenericReturnType();</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</div><div class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</div><div class="line">  &#125;</div><div class="line">  Annotation[] annotations = method.getAnnotations();</div><div class="line">  <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就获取了方法的返回值类型和方法的注解，最后调用<code>Retrofit</code>对象的<code>callAdapter()</code>方法找到对应的callAdapter，好了，我们继续,<br>retrofit对象的<code>callAdapter()</code>方法就一句代码，<code>return nextCallAdapter(null, returnType, annotations);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</div><div class="line">    Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(returnType, <span class="string">"returnType == null"</span>);</div><div class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</div><div class="line">  <span class="comment">// List&lt;CallAdapter.Factory&gt; adapterFactories,你调用addCallAdapterFactory()就将你的CallAdapterFactory加入到了这个列表中</span></div><div class="line">  <span class="comment">//即使你不调用addCallAdapterFactory()方法，系统也会加入一个默认的CallAdapterFactory,就是在第一篇文章中提到的Call返回值类型。</span></div><div class="line">  <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123; <span class="comment">// 如果返回值类型和adapter能处理的相同，则不为null</span></div><div class="line">      <span class="keyword">return</span> adapter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里将注解传给<code>callAdapter()</code>是为了我们使用更好的扩展。<br>这个扩展具体指什么呢？前面我们提到，可以添加多个<code>Converter</code>和<code>CallAdapter</code>。<br>这里就是给你这样一种能力，如果你有自定义注解，在这里你就可以拿到自己定义的注解来处理。<br><code>callAdapter()</code>方法直接从<code>adapterFactories</code>列表中获取目标类型，即直接获取你需要该方法返回什么类型的值。<br>可以看到，这里就是找哪个<code>CallAdapter</code>可以处理用户声明的该方法返回值类型，这样一个<code>CallAdapter</code>对象就生成了。</p>
<p>接下来看看<code>createResponseConverter()</code>方法，在第一篇的介绍中提到<code>Converter</code>和<code>CallAdapter</code>类似，那么我猜测代码中的创建过程应该也是类似的，来仔细瞧一瞧是不是这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</div><div class="line">  Annotation[] annotations = method.getAnnotations();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></div><div class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上面一样，调用了retrofit对象的方法，<code>responseBodyConverter()</code>方法同样一句代码:<br><code>return nextResponseBodyConverter(null, type, annotations);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(Converter.Factory skipPast,</span></span></div><div class="line">    Type type, Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(type, <span class="string">"type == null"</span>);</div><div class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</div><div class="line">  <span class="comment">// List&lt;Converter.Factory&gt; converterFactories,你调用addConverterFactory()方法就是将你的Converter.Factory加入这个列表中，因为列表有序，所以从前往后找，JSON没有明显的特征，所以需要将JSON放在最后</span></div><div class="line">  <span class="comment">// 即使你不调用addConverterFactory()方法，会加入内置的Converter.Factory</span></div><div class="line">  <span class="comment">// 下面是加入内置Converter.Factory的方法和注释。</span></div><div class="line">   <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></div><div class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></div><div class="line">      <span class="comment">// converterFactories.add(new BuiltInConverters());</span></div><div class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++)&#123;</div><div class="line">    <span class="comment">//将ResponseBody转化为你需要的类型</span></div><div class="line">    Converter&lt;ResponseBody, ?&gt; converter =</div><div class="line">        converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123; <span class="comment">// 如果能处理对应的type，则不为null</span></div><div class="line">      <span class="comment">//noinspection unchecked</span></div><div class="line">      <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这个ResponseBodyConverter，还有一个RequestBodyConverter，其实这个也是从<code>converterFactories</code>里面寻找处理请求参数的Converter。</p>
<p>到这里，<code>Retrofit</code>对象的<code>create()</code>方法就分析完了，<code>CallAdapter</code>将<code>OkHttpCall</code>对象转化成了你想要的对象，此时就可以拿你想要的对象进行操作了，也就是构造请求完成了。</p>
<h4 id="发送请求-1"><a href="#发送请求-1" class="headerlink" title="发送请求:"></a>发送请求:</h4><p>当用户调用接口中方法的时候，底层直接通过OkHttp进行发送请求。</p>
<h4 id="将服务端返回内容转化为你需要的格式-1"><a href="#将服务端返回内容转化为你需要的格式-1" class="headerlink" title="将服务端返回内容转化为你需要的格式:"></a>将服务端返回内容转化为你需要的格式:</h4><p>OkHttp接收到请求后，通过<code>Converter</code>将服务端返回内容转化为你需要的格式。所以到这里源码的流程已经走完了。</p>
<p>可以看出其实这个框架在构造请求的完成的时候工作也完成了。</p>
<p>接下来有一些需要注意的地方:</p>
<ol>
<li>接口中任何一个方法的只允许被一个Http方法注解(即[GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, HTTP]这个列表中的元素每个方法只能使用一个)</li>
<li>网络请求只要服务端有数据返回，就不算failure，Retrotfit1的时候404和500都算failure。所以当你使用Callback时，在<code>onResponse</code>函数里，使用<code>response.isSuccessful()</code>确定服务端返回正常数据还是服务端错误信息。</li>
<li>Url的拼接规则变了，初始化Retrofit对象的时候baseUrl最后一定要加’/‘。详细的内容查看下面的表格:</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">BaseUrl</th>
<th style="text-align:center">AnnotationUrl</th>
<th style="text-align:center">RequestUrl</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center">/square/end</td>
<td style="text-align:center"><a href="https://api.github.com/square/end" target="_blank" rel="external">https://api.github.com/square/end</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center">square/end</td>
<td style="text-align:center"><a href="https://api.github.com/repo/square/end" target="_blank" rel="external">https://api.github.com/repo/square/end</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center"><a href="http://z.cn/end" target="_blank" rel="external">http://z.cn/end</a></td>
<td style="text-align:center"><a href="http://z.cn/end" target="_blank" rel="external">http://z.cn/end</a></td>
</tr>
</tbody>
</table>
<p>最后放一张流程图，来源[Retrofit分析-漂亮的解耦套路][2]，是一个很棒的流程图，可以加深对此源码分析的理解。</p>
<p><img src="/img/retrofit/retrofit2.png" alt=""></p>
<p>最后是一些参考资料:</p>
<ol>
<li><a href="http://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="external">你真的会用Retrofit2吗?</a> 对Retrofit2中用到的注解进行了分类，可以让你更清晰的使用对应的注解；提供了自定义<code>ConverterFactory</code>和<code>CallAdapterFactory</code>的思路。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/05/08/retrofit2.0源码解析(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/08/retrofit2.0源码解析(上)/" itemprop="url">Retrofit2源码分析-(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-08T00:00:00+08:00">
                2016-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    千呼万唤始出来的Retrofit2.0正式版终于出来了，首先我们来看一看 Jake Wharton 的演讲，这次演讲主要讲了1.0版本的好处和问题，以及2.0版本的优势，对于好处，我们在1.0版本的使用过程中相信都已体会过了，在这里我就不重新提了，那么这第一篇就主要讲一下1.0版本的问题，和2.0在设计上是如何解决这些问题的。至于源代码的分析和对比将会放在第二篇中讲。</p>
<h3 id="Retrofit1-问题"><a href="#Retrofit1-问题" class="headerlink" title="Retrofit1 问题"></a>Retrofit1 问题</h3><ul>
<li>无法同时获取响应返回的原始数据，比如请求头或者请求的URL，和反序列化的响应返回的body。</li>
<li>如果你写了一个请求，有时同步执行，有时异步执行，你就需要写两个基本一样的请求。（如果使用RxJava可以实现，但是你要知道如何创建Observables）</li>
<li>converter的工作方式事实上稍微有点低效。</li>
<li>严重限制了我们把自定义类作为参数加入请求的能力。</li>
</ul>
<h3 id="Retrofit2"><a href="#Retrofit2" class="headerlink" title="Retrofit2"></a>Retrofit2</h3><h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>内置和OkHttp的<code>Call</code>类型一样语义的Call类型，不同的是它能做一些额外的事情，比如反序列化对象，相反OkHttp只返回原始的内容给你，这就是Retrofit2实现一个类似的<code>Call</code>而不是用OkHttp中的<code>Call</code>的原因。它是一个请求/响应对，每一个<code>Call</code>实例只能使用一次，它有Java的clone方法来创建新的实例（这个操作很廉价）。另一个巨大的好处是它把同步和异步的执行统一在了一起，这样就解决了Retrofit1中同步请求和异步请求要写两个的问题，同时，它可以被取消，这个是Retrofit1中不存在的特性。接下来我们看一下它的使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">	<span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">	Call&lt;List&lt;Contributor&gt;&gt; repoContributors(</div><div class="line">  	<span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</div><div class="line">  	<span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</div><div class="line">	&#125;</div><div class="line">	Call&lt;List&lt;Contributor&gt;&gt; call =</div><div class="line">	gitHubService.repoContributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="参数化Response对象"><a href="#参数化Response对象" class="headerlink" title="参数化Response对象"></a>参数化Response对象</h4><p>通过Response，你可以获取请求的元数据，包括 response code, message, 和headers。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">code</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">Headers <span class="title">headers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>; </div><div class="line">  <span class="function">T <span class="title">body</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">ResponseBody <span class="title">errorBody</span><span class="params">()</span></span>; </div><div class="line">  com.squareup.okhttp.<span class="function">Response <span class="title">raw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有响应的Http code是200的情况下才会进行反序列化。如果响            应没有成功，我们不知道响应是什么类型。将回返回<code>ResponseBody</code>类型，它将Content-Type，Content-Length，还有原始的body进行了封装，让你可以对响应做出想要的处理。</p>
<h4 id="动态URL参数"><a href="#动态URL参数" class="headerlink" title="动态URL参数"></a>动态URL参数</h4><p>有这样一种情况，请求列表的时候通常都要给服务端传入page，告诉服务端你要第几页数据，如果服务端将page相关的信息放在了响应头中，比如下一页page是什么，总共有几页等等，甚至服务端返回你接下来需要请求的URL。例如Github的API，Retrofit1很难处理这种情况。我们有一个新的<code>@Url</code>注解，允许你在参数中传入Url。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line">Call&lt;List&lt;Contributor&gt;&gt; repoContributorsPaginate(</div><div class="line">      <span class="meta">@Url</span> String url);</div></pre></td></tr></table></figure>
<h4 id="多样的，高效的Converters"><a href="#多样的，高效的Converters" class="headerlink" title="多样的，高效的Converters"></a>多样的，高效的Converters</h4><p>Retrofit1有一个Converter的问题，当然，对于大多数人来说这都不算是问题，但对于一个库来说，它就成了问题。考虑下面一种场景，服务端有两套API，只是返回值的类型不同，比如一个返回json，一个返回xml，可能是如下的url:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/some/xml/endpoint"</span>)</div><div class="line"><span class="meta">@GET</span>(<span class="string">"/some/json/endpoint"</span>)</div></pre></td></tr></table></figure>
<p>在Retrofit1中，你不得不定义两个接口，初始化两个<code>RestAdapter</code>，因为它只有一个Converter，每一个Converter和一个<code>RestAdapter</code>绑定在一起，但是，我们认为这些操作同属于一组API，而不是分离的API，所以，API的返回类型不应该成为你组织<code>Service</code>的方式。</p>
<p>我们会按你添加的顺序来一个个的问Converter是否可以序列化该返回值，如果它的回答是yes，那么就交给该Converter来序列化返回值。</p>
<p>两点需要注意的地方:</p>
<ul>
<li>由于JSON没有任何要求或者限制，所以我们无法知道它是否可以被JSON Converter序列化，所以JSON Converter永远会回答yes，在这种情况下，JSON Converter应该是你添加的最后一个Converter。</li>
<li>和Retrofit1不同的是，Retrofit2本身提供内置的Converter，但是只是提供了三种基础的Converter，像Json之类的Converter不会内置，所以你需要明确的声明你所用的Converter。当然，我们提供了一些Converter，但是你需要把这些Converter作为独立的依赖加入项目中。</li>
</ul>
<h4 id="多种多样插件形式的执行机制"><a href="#多种多样插件形式的执行机制" class="headerlink" title="多种多样插件形式的执行机制"></a>多种多样插件形式的执行机制</h4><p>之前，我们只有死板的执行机制。现在我们把它弄成了插件形式的，它的工作方式和Covnerter类似。<br>你可以加入你自己的方式，或者选择一个我们提供的已有的方式，我们依旧提供RxJava这个执行方式，但是它和Retrofit2库分离，需要单独的引入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Call&lt;List&lt;Contributor&gt;&gt; repoContributors(..);</div><div class="line"></div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Observable&lt;List&lt;Contributor&gt;&gt; repoContributors2(..);</div><div class="line"></div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Future&lt;List&lt;Contributor&gt;&gt; repoContributors3(..);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们单纯的查看返回类型，对于第一个函数来说，我们对执行机制的询问过程是这样的。<code>call —&gt; RxJava? No! —&gt; Call? Yes!</code></p>
<p>对于第三个Future,将会抛出一个异常，因为你没有加入你的执行机制，导致了执行机制无法执行。该过程是<code>Future —&gt; RxJava? No! —&gt; Call? No! —&gt; Throw!</code>。如果你想添加自己的执行机制，只要在初始化Retrofit对象的时候使用<code>addCallAdapterFactory()</code>，添加你自己的执行机制即可。</p>
<p>这个执行机制(Execution Mechanism)翻译到中文不是很合适，按我的理解，这个所谓的执行方式，就是生成的函数有个默认的返回值，但是返回值类型不一定是你需要的，所以，使用这个对象将生成函数的返回值转化成你需要的类型。</p>
<h4 id="由OkHttp提供底层技术支持"><a href="#由OkHttp提供底层技术支持" class="headerlink" title="由OkHttp提供底层技术支持"></a>由OkHttp提供底层技术支持</h4><p>就是说引入Retrofit2会默认引入OkHttp到你的项目中。</p>
<h4 id="极好的效率（这个我没找到相应的测试，只是Jake-Wharton在演讲中提到了）"><a href="#极好的效率（这个我没找到相应的测试，只是Jake-Wharton在演讲中提到了）" class="headerlink" title="极好的效率（这个我没找到相应的测试，只是Jake Wharton在演讲中提到了）"></a>极好的效率（这个我没找到相应的测试，只是Jake Wharton在演讲中提到了）</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/03/06/Android管理任务栈之——launchMode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/Android管理任务栈之——launchMode/" itemprop="url">Android管理任务栈之——launchMode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前遇到了一个问题，大概是有4个Activity，分别为A, B, C, D Activity，当你的Activity跳转, A -&gt; B -&gt; C -&gt; D 跳转，此时，你需要从D跳回B，不能把C<code>finish()</code>掉，因为用户中途可能会返回C，而不继续进行下一步操作；直接跳也不可以，因为默认情况下跳到B的时候，用户点返回会返回D而不是A，这个时候我知道了LaunchMode，发现这种情况很适合一个LaunchMode的使用 ———— <code>singleTask</code>，趁此机会，研究一下LaunchMode。</p>
<h2 id="LaunchMode-开篇"><a href="#LaunchMode-开篇" class="headerlink" title="LaunchMode 开篇"></a>LaunchMode 开篇</h2><p>说到LaunchMode，我们来看看官方文档怎么说 ：</p>
<blockquote>
<p>An instruction on how the activity should be launched. There are four modes that work in conjunction with activity flags (<code>FLAG_ACTIVITY_*</code> constants) in Intent objects to determine what should happen when the activity is called upon to handle an intent. They are:</p>
</blockquote>
<ul>
<li><p>“standard” </p>
</li>
<li><p>“singleTop” </p>
</li>
<li><p>“singleTask” </p>
</li>
<li><p>“singleInstance”</p>
<p>The default mode is “standard”.</p>
</li>
</ul>
<p>即Activity有4种启动模式，分别是</p>
<ul>
<li>“standard” </li>
<li>“singleTop” </li>
<li>“singleTask” </li>
<li>“singleInstance”</li>
</ul>
<p>这个需要在Manifest中指定。可以和Intent中的<code>FLAG_ACTIVITY_*</code>结合使用。</p>
<p>当然，我们要明确一点，Android中以栈的形式来管理<code>Activity</code>，至于什么是栈，请复习数据结构相关内容，这里假设大家都理解栈。</p>
<h2 id="四种模式各个模式的作用"><a href="#四种模式各个模式的作用" class="headerlink" title="四种模式各个模式的作用"></a>四种模式各个模式的作用</h2><p>先告诉大家一个方法，通过如下命令获取你当前包的<code>Activity</code>任务栈</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity activities | sed -En -e '/Stack #/p' -e '/Running activities/,/Run #0/p' | grep "包名"</div></pre></td></tr></table></figure>
<ul>
<li>“standard”</li>
</ul>
<p>大家默认新建的<code>Activity</code>就是这个模式的，这个模式相当于不对<code>Activity</code>加任何约束，即你调用<code>intent.startActivity()</code>的时候，每调用一次，就会在栈中新加一个改<code>Activity</code>。</p>
<p>先看一下我们当前的任务栈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Run #7: ActivityRecord&#123;ac97db9 u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当前只有一个<code>MainActivity</code>，此时，当我点击按钮执行<code>startActivity(new Intent(this, MainActivity.class))</code>的时候，可以看到任务栈变成了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Run #8: ActivityRecord&#123;11e0192c u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div><div class="line">Run #7: ActivityRecord&#123;ac97db9 u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div></pre></td></tr></table></figure>
<p>因为没有在<code>startActivity()</code>之后执行<code>finish()</code>方法，现在我们有了两个<code>MainActivity</code>实例，此时如果退出应用，要点两次后退键才可以。如果我再次点击按钮执行<code>startActivity(new Intent(this, MainActivity.class))</code>的时候，可以想象新的任务栈该变成什么了。</p>
<p> 接下来我们以图的形式说明该LaunchMode情况下，任务栈的样子。</p>
<p> <img src="/img/launchMode/ActivityStack--standard.png" alt="ActivityStack--standard"></p>
<p>就像上图画的那样，每启动一个新的Activity，就会添加到栈上，无论即将启动的Activity是否是同一个Activity。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>看到这个名字，先靠命名理解一下，在顶部的时候是单一存在，因为是以栈的形式来管理<code>Activity</code>的，那么顶部指的就是栈的顶部。</p>
<p>好了，上面的猜测其实已经和真正的情况是差不多了，我在此再补充几点细节。对于不是栈顶的<code>Activity</code>，即使设置了这个launchMode，依旧会创建新的Activity。例如，存在两个<code>Activity</code>A、B，它们的launchMode都是singleTop，如果你在A中启动A，栈不会新添加<code>Activity</code>，因为此时A<code>Activity</code>在栈顶，但是，如果你用A启动B，B就会被加入到栈中，此时栈就变成了AB，再拿B启动A，会产生A的新实例添加到栈内，现在栈变成了ABA。</p>
<p>拿前面举的A<code>Activity</code>例子来说，在A中启动A，由于A在栈顶，所以栈内不会添加A的新实例，自然不会调用A的<code>onCreate()</code>方法，这个时候，如果启动A的时候给A传了额外的参数，那么需要在哪里处理呢？答案是<code>onNewIntent()</code>，这里就是singleTop和standard两种launchMode不同的地方。</p>
<p>常用场景：带搜索功能的<code>Activity</code>，搜索不同的关键词不用多次启动同一个<code>Activity</code>。</p>
<ul>
<li>“singleTask”</li>
</ul>
<p>上面介绍的两个launchMode的作用不能实现栈中只存在一个<code>Activity</code>实例，但是有些时候，就像我在开头举的那个例子，业务逻辑中间要跳好几层，最终只想跳到入口界面，即栈中只需要存在一个相应的<code>Activity</code>，而不是多个。</p>
<p>总结一个singleTask的作用，若一个<code>Activity</code>的launchMode被指定为singleTask，则在对应的栈中只会存在一个实例。若这个实例不存在，则新建实例；若存在，则把在栈中该实例之上的其他实例移除出栈，并调用该<code>Activity</code>的<code>onNewIntent()</code>方法，将intent传入。 </p>
<p><img src="/img/launchMode/ActivityStack--singleTop.png" alt="ActivityStack--singleTop"></p>
<p>我们来通过代码验证一下：启动了四个<code>Activity</code>，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Run #7: ActivityRecord&#123;b53e419 u0 com.air.activitylaunchmodetestdemo/.BActivity t3909&#125;</div><div class="line">Run #6: ActivityRecord&#123;7a83deb u0 com.air.activitylaunchmodetestdemo/.AActivity t3909&#125;</div><div class="line">Run #5: ActivityRecord&#123;df9c4ad u0 com.air.activitylaunchmodetestdemo/.CActivity t3909&#125;</div><div class="line">Run #4: ActivityRecord&#123;e7c438 u0 com.air.activitylaunchmodetestdemo/.MainActivity t3909&#125;</div></pre></td></tr></table></figure>
<p>CActivity为launchMode为singleTask的<code>Activity</code>，此时，从BActivity启动CActivity，通过前面的介绍，我们猜测会调用CActivity的<code>onNewIntent()</code>方法，并且，在栈中，CActivity之上的<code>Activity</code>都会被移除，此时，执行<code>startActivity()</code>方法，最新的栈内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Run #5: ActivityRecord&#123;df9c4ad u0 com.air.activitylaunchmodetestdemo/.CActivity t3909&#125;</div><div class="line">Run #4: ActivityRecord&#123;e7c438 u0 com.air.activitylaunchmodetestdemo/.MainActivity t3909&#125;</div></pre></td></tr></table></figure>
<p>可以看出，确实是我们所介绍的效果。至于设置taskAffinity后该launchMode的表现，我们在这篇文章中不会涉及，留到下一篇文章再与大家见面。</p>
<p>常用场景：注册Activity或者启动应用的首个<code>Activity</code>，这样就不用担心任务栈内有其他的<code>Activity</code>没有销毁了。</p>
<ul>
<li>“singleInstance”</li>
</ul>
<p>这个或许可以称之为singleTask模式的加强版，对于设置了singleTask的<code>Activity</code>，我们可以让它加入到在我们当前的任务栈中，也可以新建一个任务栈，把它放入(设置taskAffinity的情况下)。但是，对于singleInstance的<code>Activity</code>，我们只能新建一个任务栈，并把它放入，没有任何<code>Activity</code>可以和它在一个栈中。</p>
<p> 那么对于我们开发的应用，其中有一个<code>Activity</code>需要给其他应用使用，比如浏览器，你从自己的应用点开一个链接，使用浏览器应用开启网页，你单机后退，直接退到了你的应用，而不是你之前浏览的其他页面，如果你在浏览器中访问的连接可以访问你的应用，那么，此时点击后退你会发现，居然在你应用所在的栈中进行了回退操作，而不是退到浏览器页面，然后你退出应用，发现这个时候反倒打开了浏览器页面，这样说有点绕，我们以图的形势来展示一下。</p>
<p><img src="/img/launchMode/ActivityStack--singleInstance.png" alt="ActivityStack--singleInstance"></p>
<p>至于常用场景，我本以为支付、分享之类的很可能会使用，但是我反编译微信查看其manifest文件的时候，发现它并没有使用这个launchMode，所以暂时这里空着，如果你有什么使用场景，可以给我留言。</p>
<p>参考文章：</p>
<ol>
<li><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/" target="_blank" rel="external">深入讲解 Android 中的 Activity launchMode</a></li>
</ol>
<p>参考书籍：</p>
<ol>
<li>《第一行代码》</li>
<li>《Android开发艺术探索》</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Air" />
          <p class="site-author-name" itemprop="name">Air</p>
           
              <p class="site-description motion-element" itemprop="description">Write Something I Want</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yunair" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Air</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
